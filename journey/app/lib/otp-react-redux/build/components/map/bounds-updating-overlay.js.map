{"version":3,"sources":["bounds-updating-overlay.js"],"names":["extendBoundsByPlaces","bounds","places","filter","place","forEach","coords","lat","lon","coreUtils","map","isValidLatLng","extend","BoundsUpdatingOverlay","MapLayer","createLeafletElement","updateLeafletElement","componentDidMount","updateBounds","props","componentDidUpdate","prevProps","componentWillUnmount","oldProps","newProps","popupLocation","leaflet","padding","newFrom","query","from","newItinBounds","itinerary","newTo","to","oldFrom","oldItinBounds","oldTo","fromChanged","toChanged","oldIntermediate","intermediatePlaces","newIntermediate","intermediateChanged","equals","fitBounds","activeLeg","legs","ui","isMobile","L","x","left","y","bottom","getBottomLeft","right","top","getTopRight","panTo","getBounds","activeStep","leg","step","steps","mapStateToProps","state","ownProps","activeSearch","otp","mapPopupLocation","currentQuery","mapDispatchToProps"],"mappings":"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","sourcesContent":["import isEqual from 'lodash.isequal'\nimport coreUtils from '../../otp-ui/core-utils/src'\nimport L from 'leaflet'\nimport { MapLayer, withLeaflet } from 'react-leaflet'\nimport { connect } from 'react-redux'\n\nimport {\n  getLeafletItineraryBounds,\n  getLeafletLegBounds\n} from '../../util/itinerary'\nimport { getActiveItinerary, getActiveSearch } from '../../util/state'\n\n/**\n * Utility to extend input Leaflet bounds to include the list of places.\n */\nfunction extendBoundsByPlaces (bounds, places = []) {\n  places\n    .filter(place => place)\n    .forEach(place => {\n      const coords = [place.lat, place.lon]\n      if (coreUtils.map.isValidLatLng(coords)) bounds.extend(coords)\n    })\n}\n\n/**\n * This MapLayer component will automatically update the leaflet bounds\n * depending on what data is in the redux store. This component does not\n * \"render\" anything on the map.\n */\nclass BoundsUpdatingOverlay extends MapLayer {\n  createLeafletElement () {}\n\n  updateLeafletElement () {}\n\n  componentDidMount () {\n    this.updateBounds(null, this.props)\n  }\n\n  componentDidUpdate (prevProps) {\n    this.updateBounds(prevProps, this.props)\n  }\n\n  componentWillUnmount () {}\n\n  /* eslint-disable-next-line complexity */\n  updateBounds (oldProps, newProps) {\n    // TODO: maybe setting bounds ought to be handled in map props...\n\n    oldProps = oldProps || {}\n    newProps = newProps || {}\n\n    // Don't auto-fit if popup us active\n    if (oldProps.popupLocation || newProps.popupLocation) return\n\n    const { map } = newProps.leaflet\n    if (!map) return\n\n    const padding = [30, 30]\n\n    // Fit map to to entire itinerary if active itinerary bounds changed\n    const newFrom = newProps.query && newProps.query.from\n    const newItinBounds = newProps.itinerary && getLeafletItineraryBounds(newProps.itinerary)\n    const newTo = newProps.query && newProps.query.to\n    const oldFrom = oldProps.query && oldProps.query.from\n    const oldItinBounds = oldProps.itinerary && getLeafletItineraryBounds(oldProps.itinerary)\n    const oldTo = oldProps.query && oldProps.query.to\n    const fromChanged = !isEqual(oldFrom, newFrom)\n    const toChanged = !isEqual(oldTo, newTo)\n    const oldIntermediate = oldProps.query && oldProps.query.intermediatePlaces\n    const newIntermediate = newProps.query && newProps.query.intermediatePlaces\n    const intermediateChanged = !isEqual(oldIntermediate, newIntermediate)\n    if (\n      (!oldItinBounds && newItinBounds) ||\n      (oldItinBounds && newItinBounds && !oldItinBounds.equals(newItinBounds))\n    ) {\n      map.fitBounds(newItinBounds, { padding })\n    // Pan to to itinerary leg if made active (clicked); newly active leg must be non-null\n    } else if (\n      newProps.itinerary &&\n        newProps.activeLeg !== oldProps.activeLeg &&\n        newProps.activeLeg !== null\n    ) {\n      map.fitBounds(\n        getLeafletLegBounds(newProps.itinerary.legs[newProps.activeLeg]),\n        { padding }\n      )\n\n    // If no itinerary update but from/to locations are present, fit to those\n    } else if (newFrom && newTo && (fromChanged || toChanged)) {\n      // On certain mobile devices (e.g., Android + Chrome), setting from and to\n      // locations via the location search component causes issues for this\n      // fitBounds invocation. The map does not appear to be visible when these\n      // prop changes are detected, so for now we should perhaps just skip this\n      // fitBounds on mobile.\n      // See https://github.com/opentripplanner/otp-react-redux/issues/133 for\n      // more info.\n      // TODO: Fix this so mobile devices will also update the bounds to the\n      // from/to locations.\n      if (!coreUtils.ui.isMobile()) {\n        const bounds = L.bounds([\n          [newFrom.lat, newFrom.lon],\n          [newTo.lat, newTo.lon]\n        ])\n        // Ensure bounds extend to include intermediatePlaces\n        extendBoundsByPlaces(bounds, newIntermediate)\n        const { x: left, y: bottom } = bounds.getBottomLeft()\n        const { x: right, y: top } = bounds.getTopRight()\n        map.fitBounds([\n          [left, bottom],\n          [right, top]\n        ], { padding })\n      }\n\n    // If only from or to is set, pan to that\n    } else if (newFrom && fromChanged) {\n      map.panTo([newFrom.lat, newFrom.lon])\n    } else if (newTo && toChanged) {\n      map.panTo([newTo.lat, newTo.lon])\n\n    // If intermediate place is added, extend bounds.\n    } else if (newIntermediate && intermediateChanged) {\n      const bounds = map.getBounds()\n      extendBoundsByPlaces(bounds, newIntermediate)\n      map.fitBounds(bounds)\n\n    // Pan to to itinerary step if made active (clicked)\n    } else if (\n      newProps.itinerary &&\n      newProps.activeLeg !== null &&\n      newProps.activeStep !== null &&\n      newProps.activeStep !== oldProps.activeStep\n    ) {\n      const leg = newProps.itinerary.legs[newProps.activeLeg]\n      const step = leg.steps[newProps.activeStep]\n      map.panTo([step.lat, step.lon])\n    }\n  }\n}\n\n// connect to the redux store\n\nconst mapStateToProps = (state, ownProps) => {\n  const activeSearch = getActiveSearch(state.otp)\n  return {\n    activeLeg: activeSearch && activeSearch.activeLeg,\n    activeStep: activeSearch && activeSearch.activeStep,\n    itinerary: getActiveItinerary(state.otp),\n    popupLocation: state.otp.ui.mapPopupLocation,\n    query: state.otp.currentQuery\n  }\n}\n\nconst mapDispatchToProps = {}\n\nexport default withLeaflet(\n  connect(mapStateToProps, mapDispatchToProps)(BoundsUpdatingOverlay)\n)\n"]}