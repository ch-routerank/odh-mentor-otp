{"version":3,"sources":["query.js"],"names":["defaultParams","TIME_FORMATS","OTP_API_TIME_FORMAT","getQueryParamProperty","paramInfo","property","query","ensureSingleAccessMode","queryModes","accessCount","filter","m","length","firstAccess","find","push","getUrlParams","qs","parse","window","location","href","split","getOtpUrlParams","Object","keys","key","startsWith","findLocationType","locations","types","match","l","indexOf","type","summarizeQuery","from","name","to","mode","getTripOptionsFromQuery","keepPlace","options","time","departArrive","date","getDefaultQueryParamValue","param","default","isNotDefaultQuery","config","activeModes","defaultModes","concat","queryIsDifferent","modesEqual","sort","every","value","index","forEach","queryParams","qp","routingTypes","includes","routingType","applicable","getDefaultQuery","defaultQuery","getFirstGeocodeResult","text","geocoderConfig","geocoder","search","then","result","firstResult","features","getLocationFromGeocodedFeature","parseLocationString","parts","coordinates","lat","lon","queryParamToLocation","planParamsToQuery","params","fromPlace","toPlace","arriveBy","parsedTime","isValid","format","intermediatePlaces","map","maybeNumber","Number","isNaN","planParamsToQueryAsync","getRoutingParams","currentQuery","ignoreRealtimeUpdates","isItinerary","rewriteFunction","itineraryRewrite","profileRewrite","assign","dateValid","OTP_API_DATE_FORMAT","timeValid","minTransitDistance","searchTimeout","onlyTransitTrips","startTimeValid","startTime","endTimeValid","endTime"],"mappings":"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","sourcesContent":["import moment from \"moment\";\nimport getGeocoder from \"../../geocoder/src\";\nimport qs from \"qs\";\n\nimport {\n  getTransitModes,\n  hasCar,\n  hasTransit,\n  isAccessMode,\n  toSentenceCase\n} from \"./itinerary\";\nimport { coordsToString, matchLatLon, stringToCoords } from \"./map\";\nimport queryParams from \"./query-params\";\nimport {\n  getCurrentTime,\n  getCurrentDate,\n  OTP_API_DATE_FORMAT,\n  OTP_API_TIME_FORMAT\n} from \"./time\";\n\n/* The list of default parameters considered in the settings panel */\n\nexport const defaultParams = [\n  \"wheelchair\",\n  \"maxWalkDistance\",\n  \"maxWalkTime\",\n  \"walkSpeed\",\n  \"maxBikeDistance\",\n  \"maxBikeTime\",\n  \"bikeSpeed\",\n  \"optimize\",\n  \"optimizeBike\",\n  \"maxEScooterDistance\",\n  \"watts\"\n];\n\n/**\n * List of time formats to parse when reading query params.\n */\nconst TIME_FORMATS = [\n  \"HH:mm:ss\",\n  \"h:mm:ss a\",\n  \"h:mm:ssa\",\n  \"h:mm a\",\n  \"h:mma\",\n  \"h:mm\",\n  \"HHmm\",\n  \"hmm\",\n  \"ha\",\n  OTP_API_TIME_FORMAT // 'HH:mm'\n];\n\n/* A function to retrieve a property value from an entry in the query-params\n * table, checking for either a static value or a function */\n\nexport function getQueryParamProperty(paramInfo, property, query) {\n  return typeof paramInfo[property] === \"function\"\n    ? paramInfo[property](query)\n    : paramInfo[property];\n}\n\nexport function ensureSingleAccessMode(queryModes) {\n  // Count the number of access modes\n  const accessCount = queryModes.filter(m => isAccessMode(m)).length;\n\n  // If multiple access modes are specified, keep only the first one\n  if (accessCount > 1) {\n    const firstAccess = queryModes.find(m => isAccessMode(m));\n    queryModes = queryModes.filter(m => !isAccessMode(m) || m === firstAccess);\n\n    // If no access modes are specified, add 'WALK' as the default\n  } else if (accessCount === 0) {\n    queryModes.push(\"WALK\");\n  }\n\n  return queryModes;\n}\n\nexport function getUrlParams() {\n  return qs.parse(window.location.href.split(\"?\")[1]);\n}\n\nexport function getOtpUrlParams() {\n  return Object.keys(getUrlParams()).filter(key => !key.startsWith(\"ui_\"));\n}\n\nfunction findLocationType(\n  location,\n  locations = [],\n  types = [\"home\", \"work\", \"suggested\"]\n) {\n  const match = locations.find(l => matchLatLon(l, location));\n  return match && types.indexOf(match.type) !== -1 ? match.type : null;\n}\n\nexport function summarizeQuery(query, locations = []) {\n  const from =\n    findLocationType(query.from, locations) || query.from.name.split(\",\")[0];\n  const to =\n    findLocationType(query.to, locations) || query.to.name.split(\",\")[0];\n  const mode = hasTransit(query.mode) ? \"Transit\" : toSentenceCase(query.mode);\n  return `${mode} from ${from} to ${to}`;\n}\n\nexport function getTripOptionsFromQuery(query, keepPlace = false) {\n  const options = { ...query };\n  // Delete time/date options and from/to\n  delete options.time;\n  delete options.departArrive;\n  delete options.date;\n  if (!keepPlace) {\n    delete options.from;\n    delete options.to;\n  }\n  return options;\n}\n\n/**\n * Gets the query param's default value that is either a constant or by\n * executing the default value function.\n */\nfunction getDefaultQueryParamValue(param) {\n  return typeof param.default === \"function\" ? param.default() : param.default;\n}\n\n/**\n * Determines whether the specified query differs from the default query, i.e.,\n * whether the user has modified any trip options (including mode) from their\n * default values.\n */\nexport function isNotDefaultQuery(query, config) {\n  const activeModes = query.mode.split(\",\");\n  const defaultModes = getTransitModes(config).concat([\"WALK\"]);\n  let queryIsDifferent = false;\n  const modesEqual =\n    activeModes.length === defaultModes.length &&\n    activeModes.sort().every((value, index) => {\n      return value === defaultModes.sort()[index];\n    });\n\n  if (!modesEqual) {\n    queryIsDifferent = true;\n  } else {\n    defaultParams.forEach(param => {\n      const paramInfo = queryParams.find(qp => qp.name === param);\n      // Check that the parameter applies to the specified routingType\n      if (!paramInfo.routingTypes.includes(query.routingType)) return;\n      // Check that the applicability test (if provided) is satisfied\n      if (\n        typeof paramInfo.applicable === \"function\" &&\n        !paramInfo.applicable(query, config)\n      )\n        return;\n      if (query[param] !== getDefaultQueryParamValue(paramInfo)) {\n        queryIsDifferent = true;\n      }\n    });\n  }\n  return queryIsDifferent;\n}\n\n/**\n * Get the default query to OTP based on the given config.\n */\nexport function getDefaultQuery() {\n  const defaultQuery = { routingType: \"ITINERARY\" };\n  queryParams\n    .filter(qp => \"default\" in qp)\n    .forEach(qp => {\n      defaultQuery[qp.name] = getDefaultQueryParamValue(qp);\n    });\n  return defaultQuery;\n}\n\n/**\n * Geocode utility for returning the first result for the provided place name text.\n * @param  {string} text - text to search\n * @param  {Object} geocoderConfig\n * @return {Location}\n */\nasync function getFirstGeocodeResult(text, geocoderConfig) {\n  const geocoder = getGeocoder(geocoderConfig);\n  // Attempt to geocode search text and return first result if found.\n  // TODO: Import geocoder from @opentripplanner\n  return geocoder.search({ text }).then(result => {\n    const firstResult = result.features && result.features[0];\n    if (firstResult) {\n      return geocoder.getLocationFromGeocodedFeature(firstResult);\n    }\n    return null;\n  });\n}\n\n/**\n * OTP allows passing a location in the form '123 Main St::lat,lon', so we check\n * for the double colon and parse the coordinates accordingly.\n * @param  {string} value - query param for place described above\n * @return {Location} - location or null if the value is falsey or the parsed\n *                      coordinates do not result in both a lat and lon\n */\nexport function parseLocationString(value) {\n  if (!value) return null;\n  const parts = value.split(\"::\");\n  const coordinates = parts[1]\n    ? stringToCoords(parts[1])\n    : stringToCoords(parts[0]);\n  const name = parts[1] ? parts[0] : coordsToString(coordinates);\n  return coordinates.length === 2\n    ? {\n        name: name || null,\n        lat: coordinates[0] || null,\n        lon: coordinates[1] || null\n      }\n    : null;\n}\n\n/**\n * Convert a string query param for a from or to place into a location. If\n * coordinates not provided and geocoder config is present, use the first\n * geocoded result.\n * @param  {string} value\n * @param  {Object} [geocoderConfig=null]\n * @return {Location}\n */\nasync function queryParamToLocation(value, geocoderConfig) {\n  let location = parseLocationString(value);\n  if (!location && value && geocoderConfig) {\n    // If a valid location was not found, but the place name text exists,\n    // attempt to geocode the name.\n    location = await getFirstGeocodeResult(value, geocoderConfig);\n  }\n  return location;\n}\n\n/**\n * Create a otp query based on a the url params.\n *\n * @param  {Object} params An object representing the parsed querystring of url\n *    params.\n */\nexport function planParamsToQuery(params) {\n  const query = {};\n  Object.keys(params).forEach(key => {\n    switch (key) {\n      case \"fromPlace\":\n        query.from = parseLocationString(params.fromPlace);\n        break;\n      case \"toPlace\":\n        query.to = parseLocationString(params.toPlace);\n        break;\n      case \"arriveBy\":\n        query.departArrive =\n          params.arriveBy === \"true\"\n            ? \"ARRIVE\"\n            : params.arriveBy === \"false\"\n            ? \"DEPART\"\n            : \"NOW\";\n        break;\n      case \"date\":\n        query.date = params.date || getCurrentDate();\n        break;\n      case \"time\":\n        {\n          const parsedTime = moment(params.time, TIME_FORMATS);\n          query.time = parsedTime.isValid()\n            ? parsedTime.format(OTP_API_TIME_FORMAT)\n            : getCurrentTime();\n        }\n        break;\n      case \"intermediatePlaces\":\n        // If query has intermediate places, ensure that they are parsed\n        // as locations.\n        query.intermediatePlaces = params.intermediatePlaces\n          ? params.intermediatePlaces.split(\",\").map(parseLocationString)\n          : [];\n        break;\n      default: {\n        const maybeNumber = Number(params[key]);\n        // If the param value is an empty string literal and is not a number,\n        // use string value. Else, use parsed number value.\n        // See https://github.com/opentripplanner/otp-ui/issues/50\n        query[key] =\n          params[key] === \"\" || Number.isNaN(maybeNumber)\n            ? params[key]\n            : maybeNumber;\n        break;\n      }\n    }\n  });\n  return query;\n}\n\n/**\n * Async method to create a otp query based on a the url params. This provides\n * the same functionality as planParamsToQuery, except that it will also attempt\n * to geocode the input from and to strings if no lat/lng values were provided.\n *\n * @param  {Object} params An object representing the parsed querystring of url\n *    params.\n * @param config the config in the otp-rr store.\n */\nexport async function planParamsToQueryAsync(params, config = {}) {\n  // Construct query from plan params.\n  const query = planParamsToQuery(params);\n  // Attempt to geocode from and to params if the string parsing does not return\n  // valid locations.\n  if (!query.from) {\n    query.from = await queryParamToLocation(params.fromPlace, config.geocoder);\n  }\n  if (!query.to) {\n    query.to = await queryParamToLocation(params.toPlace, config.geocoder);\n  }\n  return query;\n}\n\n/**\n * Create an object that can be used as a querystring in making an OTP\n * PlannerResource request.\n *\n * See http://otp-docs.ibi-transit.com/api/resource_PlannerResource.html\n *\n * @param  {Object} config  The OTP application config. See types#configType\n * @param  {Object} currentQuery  The current query parameters as saved in the\n *   application state. This method does some extra logic on top of this data\n *   in order to create a request suitable for OTP. See __tests__/query.js#L14 for more.\n * @param  {boolean} ignoreRealtimeUpdates  If true, will create a request that\n *   does not use realtime data.\n */\nexport function getRoutingParams(config, currentQuery, ignoreRealtimeUpdates) {\n  const routingType = currentQuery.routingType;\n  const isItinerary = routingType === \"ITINERARY\";\n  let params = {};\n\n  // Start with the universe of OTP parameters defined in query-params.js:\n  queryParams\n    .filter(qp => {\n      // A given parameter is included in the request if all of the following:\n      // 1. Must apply to the active routing type (ITINERARY or PROFILE)\n      // 2. Must be included in the current user-defined query\n      // 3. Must pass the parameter's applicability test, if one is specified\n      return (\n        qp.routingTypes.indexOf(routingType) !== -1 &&\n        qp.name in currentQuery &&\n        (typeof qp.applicable !== \"function\" ||\n          qp.applicable(currentQuery, config))\n      );\n    })\n    .forEach(qp => {\n      // Translate the applicable parameters according to their rewrite\n      // functions (if provided)\n      const rewriteFunction = isItinerary\n        ? qp.itineraryRewrite\n        : qp.profileRewrite;\n      params = Object.assign(\n        params,\n        rewriteFunction\n          ? rewriteFunction(currentQuery[qp.name])\n          : { [qp.name]: currentQuery[qp.name] }\n      );\n    });\n\n  // Additional processing specific to ITINERARY mode\n  if (isItinerary) {\n    // override ignoreRealtimeUpdates if provided\n    if (typeof ignoreRealtimeUpdates === \"boolean\") {\n      params.ignoreRealtimeUpdates = ignoreRealtimeUpdates;\n    }\n\n    // check date/time validity; ignore both if either is invalid\n    const dateValid = moment(params.date, OTP_API_DATE_FORMAT).isValid();\n    const timeValid = moment(params.time, OTP_API_TIME_FORMAT).isValid();\n\n    if (!dateValid || !timeValid) {\n      delete params.time;\n      delete params.date;\n    }\n\n    // temp: set additional parameters for CAR_HAIL or CAR_RENT trips\n    if (\n      params.mode &&\n      (params.mode.includes(\"CAR_HAIL\") || params.mode.includes(\"CAR_RENT\"))\n    ) {\n      params.minTransitDistance = \"50%\";\n      // increase search timeout because these queries can take a while\n      params.searchTimeout = 10000;\n    }\n\n    // set onlyTransitTrips for car rental searches\n    if (params.mode && params.mode.includes(\"CAR_RENT\")) {\n      params.onlyTransitTrips = true;\n    }\n\n    // Additional processing specific to PROFILE mode\n  } else {\n    // check start and end time validity; ignore both if either is invalid\n    const startTimeValid = moment(\n      params.startTime,\n      OTP_API_TIME_FORMAT\n    ).isValid();\n    const endTimeValid = moment(params.endTime, OTP_API_TIME_FORMAT).isValid();\n\n    if (!startTimeValid || !endTimeValid) {\n      delete params.startTimeValid;\n      delete params.endTimeValid;\n    }\n  }\n\n  // TODO: check that valid from/to locations are provided\n\n  // hack to add walking to driving/TNC trips\n  if (hasCar(params.mode)) {\n    params.mode += \",WALK\";\n  }\n\n  return params;\n}\n"]}