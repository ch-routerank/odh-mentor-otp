{"version":3,"sources":["viewer.js"],"names":["formatDuration","formatSecondsAfterMidnight","getUserTimezone","coreUtils","time","ONE_HOUR_IN_SECONDS","ONE_DAY_IN_SECONDS","getFormattedStopTime","stopTime","homeTimezone","soonText","timeFormat","useSchedule","departureTime","scheduledDeparture","realtimeDeparture","userTimeZone","inHomeTimezone","now","tz","serviceDay","departureTimeRemainder","daysAfterServiceDay","departureDay","add","vehicleDepartsToday","dayOfYear","secondsUntilDeparture","unix","departsInFuture","showCountdown","countdownString","formattedTime","showDayOfWeek","float","realtimeState","color","fontSize","marginRight","marginLeft","marginBottom","format","getRouteIdForPattern","pattern","patternIdParts","id","split","routeId","getStatusLabel","delay","backgroundColor","Math","abs","getStopTimesByPattern","stopData","stopTimesByPattern","routes","stopTimes","forEach","patternTimes","headsign","times","route","find","r","console","warn","filteredTimes","filter","stopIndex","stopCount","concat"],"mappings":";;;;;;;;;;AAAA;;AACA;;AACA;;AACA;;AAEA;;;;AAEA,MAAM;AACJA,EAAAA,cADI;AAEJC,EAAAA,0BAFI;AAGJC,EAAAA;AAHI,IAIFC,aAAUC,IAJd;AAMA,MAAMC,mBAAmB,GAAG,IAA5B;AACA,MAAMC,kBAAkB,GAAG,KAA3B;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACO,SAASC,oBAAT,CAA+BC,QAA/B,EAAyCC,YAAzC,EAAuDC,QAAQ,GAAG,KAAlE,EAAyEC,UAAzE,EAAqFC,WAAW,GAAG,KAAnG,EAA0G;AAC/G,QAAMC,aAAa,GAAGD,WAAW,GAC7BJ,QAAQ,CAACM,kBADoB,GAE7BN,QAAQ,CAACO,iBAFb;AAGA,QAAMC,YAAY,GAAGd,eAAe,EAApC;AACA,QAAMe,cAAc,GAAGR,YAAY,IAAIA,YAAY,KAAKO,YAAxD;AAEA,QAAME,GAAG,GAAG,uBAASC,EAAT,CAAYV,YAAZ,CAAZ;AACA,QAAMW,UAAU,GAAG,qBAAOZ,QAAQ,CAACY,UAAT,GAAsB,IAA7B,EAAmCD,EAAnC,CAAsCV,YAAtC,CAAnB,CAR+G,CAS/G;AACA;AACA;AACA;;AACA,QAAMY,sBAAsB,GAAGR,aAAa,GAAGP,kBAA/C;AACA,QAAMgB,mBAAmB,GAAG,CAACT,aAAa,GAAGQ,sBAAjB,IAA2Cf,kBAAvE;AACA,QAAMiB,YAAY,GAAGH,UAAU,CAACI,GAAX,CAAeF,mBAAf,EAAoC,KAApC,CAArB;AACA,QAAMG,mBAAmB,GAAGP,GAAG,CAACQ,SAAJ,OAAoBH,YAAY,CAACG,SAAb,EAAhD,CAhB+G,CAiB/G;AACA;;AACA,QAAMC,qBAAqB,GAAId,aAAa,GAAGL,QAAQ,CAACY,UAA1B,GAAwCF,GAAG,CAACU,IAAJ,EAAtE,CAnB+G,CAoB/G;AACA;;AACA,QAAMC,eAAe,GAAGF,qBAAqB,GAAG,CAAhD,CAtB+G,CAuB/G;;AACA,QAAMG,aAAa,GAAGH,qBAAqB,GAAGtB,mBAAxB,IAA+CwB,eAArE,CAxB+G,CA0B/G;;AACA,QAAME,eAAe,GAAGJ,qBAAqB,GAAG,EAAxB,GACpBjB,QADoB,GAEpBV,cAAc,CAAC2B,qBAAD,CAFlB;AAGA,QAAMK,aAAa,GAAG/B,0BAA0B,CAC9CY,aAD8C,EAE9C;AACA;AACAI,EAAAA,cAAc,GAAGN,UAAH,GAAiB,GAAEA,UAAW,IAJE,CAAhD,CA9B+G,CAoC/G;AACA;AACA;AACA;;AACA,QAAMsB,aAAa,GAAG,CAACR,mBAAD,IAAwB,CAACK,aAA/C;AACA,sBACE,uDACE;AAAK,IAAA,KAAK,EAAE;AAAEI,MAAAA,KAAK,EAAE;AAAT;AAAZ,KACG1B,QAAQ,CAAC2B,aAAT,KAA2B,SAA3B,gBACG,6BAAC,aAAD;AACA,IAAA,IAAI,EAAC,KADL;AAEA,IAAA,KAAK,EAAE;AAAEC,MAAAA,KAAK,EAAE,MAAT;AAAiBC,MAAAA,QAAQ,EAAE,OAA3B;AAAoCC,MAAAA,WAAW,EAAE;AAAjD;AAFP,IADH,gBAIG,6BAAC,aAAD;AACA,IAAA,IAAI,EAAC,SADL;AAEA,IAAA,KAAK,EAAE;AAAEF,MAAAA,KAAK,EAAE,MAAT;AAAiBC,MAAAA,QAAQ,EAAE,OAA3B;AAAoCC,MAAAA,WAAW,EAAE;AAAjD;AAFP,IALN,CADF,eAWE;AAAK,IAAA,KAAK,EAAE;AAAEC,MAAAA,UAAU,EAAE,EAAd;AAAkBF,MAAAA,QAAQ,EAAEJ,aAAa,GAAG,EAAH,GAAQ;AAAjD;AAAZ,KACGA,aAAa,iBACZ;AAAK,IAAA,KAAK,EAAE;AAAEO,MAAAA,YAAY,EAAE,CAAC;AAAjB;AAAZ,KAAmCjB,YAAY,CAACkB,MAAb,CAAoB,MAApB,CAAnC,CAFJ,eAIE,0CACGX,aAAa,CACZ;AADY,IAEVC,eAFU,CAGZ;AAHY,IAIVC,aALN,CAJF,CAXF,CADF;AA2BD;;AAEM,SAASU,oBAAT,CAA+BC,OAA/B,EAAwC;AAC7C,QAAMC,cAAc,GAAGD,OAAO,CAACE,EAAR,CAAWC,KAAX,CAAiB,GAAjB,CAAvB;AACA,QAAMC,OAAO,GAAGH,cAAc,CAAC,CAAD,CAAd,GAAoB,GAApB,GAA0BA,cAAc,CAAC,CAAD,CAAxD;AACA,SAAOG,OAAP;AACD,C,CAED;;;AACO,SAASC,cAAT,CAAyBC,KAAzB,EAAgC;AACrC;AACA,MAAIA,KAAK,GAAG,EAAZ,EAAgB;AACd,wBACE;AAAK,MAAA,SAAS,EAAC,cAAf;AAA8B,MAAA,KAAK,EAAE;AAAEC,QAAAA,eAAe,EAAE;AAAnB;AAArC,OACGlD,cAAc,CAACiD,KAAD,CADjB,UADF;AAKD,GARoC,CAUrC;;;AACA,MAAIA,KAAK,GAAG,CAAC,EAAb,EAAiB;AACf,wBACE;AAAK,MAAA,SAAS,EAAC,cAAf;AAA8B,MAAA,KAAK,EAAE;AAAEC,QAAAA,eAAe,EAAE;AAAnB;AAArC,OACGlD,cAAc,CAACmD,IAAI,CAACC,GAAL,CAASH,KAAT,CAAD,CADjB,WADF;AAKD,GAjBoC,CAmBrC;;;AACA,sBACE;AAAK,IAAA,SAAS,EAAC,cAAf;AAA8B,IAAA,KAAK,EAAE;AAAEC,MAAAA,eAAe,EAAE;AAAnB;AAArC,eADF;AAKD;;AAEM,SAASG,qBAAT,CAAgCC,QAAhC,EAA0C;AAC/C,QAAMC,kBAAkB,GAAG,EAA3B;;AACA,MAAID,QAAQ,IAAIA,QAAQ,CAACE,MAArB,IAA+BF,QAAQ,CAACG,SAA5C,EAAuD;AACrDH,IAAAA,QAAQ,CAACG,SAAT,CAAmBC,OAAnB,CAA2BC,YAAY,IAAI;AACzC,YAAMZ,OAAO,GAAGL,oBAAoB,CAACiB,YAAY,CAAChB,OAAd,CAApC;AACA,YAAMiB,QAAQ,GAAGD,YAAY,CAACE,KAAb,CAAmB,CAAnB,KAAyBF,YAAY,CAACE,KAAb,CAAmB,CAAnB,EAAsBD,QAAhE;AACAD,MAAAA,YAAY,CAAChB,OAAb,CAAqBiB,QAArB,GAAgCA,QAAhC;AACA,YAAMf,EAAE,GAAI,GAAEE,OAAQ,IAAGa,QAAS,EAAlC;;AACA,UAAI,EAAEf,EAAE,IAAIU,kBAAR,CAAJ,EAAiC;AAC/B,cAAMO,KAAK,GAAGR,QAAQ,CAACE,MAAT,CAAgBO,IAAhB,CAAqBC,CAAC,IAAIA,CAAC,CAACnB,EAAF,KAASE,OAAnC,CAAd,CAD+B,CAE/B;AACA;AACA;AACA;AACA;;AACA,YAAI,CAACe,KAAL,EAAY;AACVG,UAAAA,OAAO,CAACC,IAAR,CAAc,iBAAgBnB,OAAQ,gFAAtC;AACA;AACD;;AACDQ,QAAAA,kBAAkB,CAACV,EAAD,CAAlB,GAAyB;AACvBA,UAAAA,EADuB;AAEvBiB,UAAAA,KAFuB;AAGvBnB,UAAAA,OAAO,EAAEgB,YAAY,CAAChB,OAHC;AAIvBkB,UAAAA,KAAK,EAAE;AAJgB,SAAzB;AAMD;;AACD,YAAMM,aAAa,GAAGR,YAAY,CAACE,KAAb,CAAmBO,MAAnB,CAA0B5D,QAAQ,IAAI;AAC1D,eAAOA,QAAQ,CAAC6D,SAAT,GAAqB7D,QAAQ,CAAC8D,SAAT,GAAqB,CAAjD,CAD0D,CACP;AACpD,OAFqB,CAAtB;AAGAf,MAAAA,kBAAkB,CAACV,EAAD,CAAlB,CAAuBgB,KAAvB,GAA+BN,kBAAkB,CAACV,EAAD,CAAlB,CAAuBgB,KAAvB,CAA6BU,MAA7B,CAAoCJ,aAApC,CAA/B;AACD,KA3BD;AA4BD;;AACD,SAAOZ,kBAAP;AACD","sourcesContent":["import coreUtils from '../otp-ui/core-utils/src'\nimport moment from 'moment'\nimport 'moment-timezone'\nimport React from 'react'\n\nimport Icon from '../components/narrative/icon'\n\nconst {\n  formatDuration,\n  formatSecondsAfterMidnight,\n  getUserTimezone\n} = coreUtils.time\n\nconst ONE_HOUR_IN_SECONDS = 3600\nconst ONE_DAY_IN_SECONDS = 86400\n\n/**\n * Helper method to generate stop time w/ status icon\n *\n * @param  {Object} stopTime  A stopTime object as received from a transit index API\n * @param  {string} [homeTimezone]  If configured, the timezone of the area\n * @param  {string} [soonText='Due']  The text to display for departure times\n *    about to depart in a short amount of time\n * @param  {string} timeFormat  A valid moment.js formatting string\n * @param  {boolean} useSchedule  Whether to use scheduled departure (otherwise uses realtime)\n */\nexport function getFormattedStopTime (stopTime, homeTimezone, soonText = 'Due', timeFormat, useSchedule = false) {\n  const departureTime = useSchedule\n    ? stopTime.scheduledDeparture\n    : stopTime.realtimeDeparture\n  const userTimeZone = getUserTimezone()\n  const inHomeTimezone = homeTimezone && homeTimezone === userTimeZone\n\n  const now = moment().tz(homeTimezone)\n  const serviceDay = moment(stopTime.serviceDay * 1000).tz(homeTimezone)\n  // Determine if arrival occurs on different day, making sure to account for\n  // any extra days added to the service day if it arrives after midnight. Note:\n  // this can handle the rare (and non-existent?) case where an arrival occurs\n  // 48:00 hours (or more) from the start of the service day.\n  const departureTimeRemainder = departureTime % ONE_DAY_IN_SECONDS\n  const daysAfterServiceDay = (departureTime - departureTimeRemainder) / ONE_DAY_IN_SECONDS\n  const departureDay = serviceDay.add(daysAfterServiceDay, 'day')\n  const vehicleDepartsToday = now.dayOfYear() === departureDay.dayOfYear()\n  // Determine whether to show departure as countdown (e.g. \"5 min\") or as HH:mm\n  // time.\n  const secondsUntilDeparture = (departureTime + stopTime.serviceDay) - now.unix()\n  // Determine if vehicle arrives after midnight in order to advance the day of\n  // the week when showing arrival time/day.\n  const departsInFuture = secondsUntilDeparture > 0\n  // Show the exact time if the departure happens within an hour.\n  const showCountdown = secondsUntilDeparture < ONE_HOUR_IN_SECONDS && departsInFuture\n\n  // Use \"soon text\" (e.g., Due) if vehicle is approaching.\n  const countdownString = secondsUntilDeparture < 60\n    ? soonText\n    : formatDuration(secondsUntilDeparture)\n  const formattedTime = formatSecondsAfterMidnight(\n    departureTime,\n    // Only show timezone (e.g., PDT) if user is not in home time zone (e.g., user\n    // in New York, but viewing a trip planner for service based in Los Angeles).\n    inHomeTimezone ? timeFormat : `${timeFormat} z`\n  )\n  // We only want to show the day of the week if the arrival is on a\n  // different day and we're not showing the countdown string. This avoids\n  // cases such as when it's Wednesday at 11:55pm and an arrival occurs at\n  // Thursday 12:19am. We don't want the time to read: 'Thursday, 24 minutes'.\n  const showDayOfWeek = !vehicleDepartsToday && !showCountdown\n  return (\n    <div>\n      <div style={{ float: 'left' }}>\n        {stopTime.realtimeState === 'UPDATED'\n          ? <Icon\n            type='rss'\n            style={{ color: '#888', fontSize: '0.8em', marginRight: 2 }} />\n          : <Icon\n            type='clock-o'\n            style={{ color: '#888', fontSize: '0.8em', marginRight: 2 }} />\n        }\n      </div>\n      <div style={{ marginLeft: 20, fontSize: showDayOfWeek ? 12 : 14 }}>\n        {showDayOfWeek &&\n          <div style={{ marginBottom: -4 }}>{departureDay.format('dddd')}</div>\n        }\n        <div>\n          {showCountdown\n            // Show countdown string (e.g., 3 min or Due)\n            ? countdownString\n            // Show formatted time (with timezone if user is not in home timezone)\n            : formattedTime\n          }\n        </div>\n      </div>\n    </div>\n  )\n}\n\nexport function getRouteIdForPattern (pattern) {\n  const patternIdParts = pattern.id.split(':')\n  const routeId = patternIdParts[0] + ':' + patternIdParts[1]\n  return routeId\n}\n\n// helper method to generate status label\nexport function getStatusLabel (delay) {\n  // late departure\n  if (delay > 60) {\n    return (\n      <div className='status-label' style={{ backgroundColor: '#d9534f' }}>\n        {formatDuration(delay)} Late\n      </div>\n    )\n  }\n\n  // early departure\n  if (delay < -60) {\n    return (\n      <div className='status-label' style={{ backgroundColor: '#337ab7' }}>\n        {formatDuration(Math.abs(delay))} Early\n      </div>\n    )\n  }\n\n  // on-time departure\n  return (\n    <div className='status-label' style={{ backgroundColor: '#5cb85c' }}>\n      On Time\n    </div>\n  )\n}\n\nexport function getStopTimesByPattern (stopData) {\n  const stopTimesByPattern = {}\n  if (stopData && stopData.routes && stopData.stopTimes) {\n    stopData.stopTimes.forEach(patternTimes => {\n      const routeId = getRouteIdForPattern(patternTimes.pattern)\n      const headsign = patternTimes.times[0] && patternTimes.times[0].headsign\n      patternTimes.pattern.headsign = headsign\n      const id = `${routeId}-${headsign}`\n      if (!(id in stopTimesByPattern)) {\n        const route = stopData.routes.find(r => r.id === routeId)\n        // in some cases, the TriMet transit index will not return all routes\n        // that serve a stop. Perhaps it doesn't return some routes if the\n        // route only performs a drop-off at the stop... not quite sure. So a\n        // check is needed to make sure we don't add data for routes not found\n        // from the routes query.\n        if (!route) {\n          console.warn(`Route with id ${routeId} not found in list of routes! No stop times from this route will be displayed.`)\n          return\n        }\n        stopTimesByPattern[id] = {\n          id,\n          route,\n          pattern: patternTimes.pattern,\n          times: []\n        }\n      }\n      const filteredTimes = patternTimes.times.filter(stopTime => {\n        return stopTime.stopIndex < stopTime.stopCount - 1 // ensure that this isn't the last stop\n      })\n      stopTimesByPattern[id].times = stopTimesByPattern[id].times.concat(filteredTimes)\n    })\n  }\n  return stopTimesByPattern\n}\n"]}