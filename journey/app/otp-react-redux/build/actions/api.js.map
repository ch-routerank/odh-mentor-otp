{"version":3,"sources":["api.js"],"names":["fetch","require","hasCar","coreUtils","itinerary","getTripOptionsFromQuery","getUrlParams","query","randId","storage","OTP_API_DATE_FORMAT","OTP_API_TIME_FORMAT","time","nonRealtimeRoutingResponse","routingRequest","routingResponse","routingError","toggleTracking","rememberSearch","forgetSearch","formatRecentPlace","place","type","icon","id","timestamp","Date","getTime","formatRecentSearch","url","otpState","currentQuery","isStoredPlace","indexOf","getActiveItinerary","searches","activeItinerary","routingType","urlParams","hasSearches","Object","keys","length","ui_activeItinerary","routingQuery","searchId","dispatch","getState","state","otp","isNewSearch","console","warn","iterations","config","modes","combinations","map","mode","params","pending","forEach","injectedParams","i","requestId","constructRoutingQuery","getOtpFetchOptions","then","getJsonAndCheckResponse","json","response","user","trackRecent","from","to","location","catch","error","ui_activeSearch","updateOtpUrlParams","storeTripHistory","loggedInUser","res","status","Error","includeToken","apiBaseUrl","apiKey","token","api","persistence","otp_middleware","isOtpServerSameAsMiddleware","host","accessToken","ignoreRealtimeUpdates","rt","routingTypes","find","key","planEndpoint","port","path","getRoutingParams","qs","stringify","arrayFormat","isItinerary","queryParams","filter","qp","name","applicable","rewriteFunction","itineraryRewrite","profileRewrite","assign","dateValid","date","isValid","timeValid","includes","minTransitDistance","searchTimeout","onlyTransitTrips","startTimeValid","startTime","endTimeValid","endTime","parkAndRideError","parkAndRideResponse","parkAndRideQuery","endpoint","join","createQueryAction","bikeRentalError","bikeRentalResponse","bikeRentalQuery","carRentalResponse","carRentalError","carRentalQuery","vehicleRentalResponse","vehicleRentalError","vehicleRentalQuery","findStopResponse","findStopError","findStop","stopId","serviceId","postprocess","payload","findRoutesAtStop","findStopTimesForStop","noThrottle","findTripResponse","findTripError","findTrip","tripId","findStopsForTrip","findStopTimesForTrip","findGeometryForTrip","findStopsForTripResponse","findStopsForTripError","rewritePayload","stops","findStopTimesForTripResponse","findStopTimesForTripError","stopTimes","findGeometryForTripResponse","findGeometryForTripError","geometry","findStopTimesForStopResponse","findStopTimesForStopError","otherParams","nowInSeconds","Math","floor","findRoutesResponse","findRoutesError","findRoutes","routes","rte","findPatternsForRouteResponse","findPatternsForRouteError","findRouteResponse","findRouteError","findRoute","routeId","findPatternsForRoute","patterns","ptn","findGeometryForPattern","patternId","findGeometryForPatternResponse","findGeometryForPatternError","transportationNetworkCompanyEtaResponse","transportationNetworkCompanyEtaError","getTransportationNetworkCompanyEtaEstimate","companies","estimates","transportationNetworkCompanyRideResponse","transportationNetworkCompanyRideError","getTransportationNetworkCompanyRideEstimate","company","rideType","rideEstimate","receivedNearbyStopsResponse","receivedNearbyStopsError","findNearbyStops","radius","stop","distance","latitude","lat","longitude","lon","sort","a","b","max","slice","receivedRoutesAtStopResponse","receivedRoutesAtStopError","receivedStopsWithinBBoxResponse","receivedStopsWithinBBoxError","findStopsWithinBBox","clearStops","throttledUrls","now","TEN_SECONDS","window","setInterval","responseAction","errorAction","options","alternateTransitIndex","services","log","apiRoot","throttleKey","fetchOptions","err","setUrlSearch","replaceCurrent","base","router","pathname","otpParams"],"mappings":"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","sourcesContent":["/* globals fetch */\nimport { push, replace } from 'connected-react-router'\nimport haversine from 'haversine'\nimport moment from 'moment'\nimport hash from 'object-hash'\nimport coreUtils from '../otp-ui/core-utils/src'\nimport queryParams from '../otp-ui/core-utils/src/query-params'\nimport { createAction } from 'redux-actions'\nimport qs from 'qs'\n\nimport { rememberPlace } from './map'\nimport { getStopViewerConfig, queryIsValid } from '../util/state'\nimport { getSecureFetchOptions } from '../util/middleware'\n\nif (typeof (fetch) === 'undefined') require('isomorphic-fetch')\n\nconst { hasCar } = coreUtils.itinerary\nconst { getTripOptionsFromQuery, getUrlParams } = coreUtils.query\nconst { randId } = coreUtils.storage\nconst { OTP_API_DATE_FORMAT, OTP_API_TIME_FORMAT } = coreUtils.time\n\n// Generic API actions\n\nexport const nonRealtimeRoutingResponse = createAction('NON_REALTIME_ROUTING_RESPONSE')\nexport const routingRequest = createAction('ROUTING_REQUEST')\nexport const routingResponse = createAction('ROUTING_RESPONSE')\nexport const routingError = createAction('ROUTING_ERROR')\nexport const toggleTracking = createAction('TOGGLE_TRACKING')\nexport const rememberSearch = createAction('REMEMBER_SEARCH')\nexport const forgetSearch = createAction('FORGET_SEARCH')\n\nfunction formatRecentPlace (place) {\n  return {\n    ...place,\n    type: 'recent',\n    icon: 'clock-o',\n    id: `recent-${randId()}`,\n    timestamp: new Date().getTime()\n  }\n}\n\nfunction formatRecentSearch (url, otpState) {\n  return {\n    query: getTripOptionsFromQuery(otpState.currentQuery, true),\n    url,\n    id: randId(),\n    timestamp: new Date().getTime()\n  }\n}\n\nfunction isStoredPlace (place) {\n  return ['home', 'work', 'suggested', 'stop'].indexOf(place.type) !== -1\n}\n\n/**\n * Compute the initial activeItinerary. If this is the first search of\n * session (i.e. searches lookup is empty/null) AND an activeItinerary ID\n * is specified in URL parameters, use that ID. Otherwise, use null/0.\n */\nfunction getActiveItinerary (otpState) {\n  const {currentQuery, searches} = otpState\n  let activeItinerary = currentQuery.routingType === 'ITINERARY' ? 0 : null\n  // We cannot use window.history.state here to check for the active\n  // itinerary param because it is unreliable in some states (e.g.,\n  // when the print layout component first loads).\n  const urlParams = getUrlParams()\n  const hasSearches = !searches || Object.keys(searches).length === 0\n  if (hasSearches && urlParams.ui_activeItinerary) {\n    activeItinerary = +urlParams.ui_activeItinerary\n  }\n  return activeItinerary\n}\n\n/**\n * Send a routing query to the OTP backend.\n *\n * NOTE: We need a random ID so that when a user reloads the page (clearing the\n * state), performs searches, and presses back to load previous searches\n * that are no longer contained in the state we don't confuse the search IDs\n * with search IDs from the new session. If we were to use sequential numbers\n * as IDs, we would run into this problem.\n */\nexport function routingQuery (searchId = null) {\n  return async function (dispatch, getState) {\n    // FIXME: batchId is searchId for now.\n    const state = getState()\n    const otpState = state.otp\n\n    const isNewSearch = !searchId\n    if (isNewSearch) searchId = randId()\n    // Don't permit a routing query if the query is invalid\n    if (!queryIsValid(otpState)) {\n      console.warn('Query is invalid. Aborting routing query', otpState.currentQuery)\n      return\n    }\n    const activeItinerary = getActiveItinerary(otpState)\n    const routingType = otpState.currentQuery.routingType\n    // For multiple mode combinations, gather injected params from config/query.\n    // Otherwise, inject nothing (rely on what's in current query) and perform\n    // one iteration.\n    const iterations = otpState.config.modes && otpState.config.modes.combinations\n      ? otpState.config.modes.combinations.map(({mode, params}) => ({mode, ...params}))\n      : [{}]\n    dispatch(routingRequest({ activeItinerary, routingType, searchId, pending: iterations.length }))\n    iterations.forEach((injectedParams, i) => {\n      const requestId = randId()\n      // fetch a realtime route\n      const query = constructRoutingQuery(otpState, false, injectedParams)\n      fetch(query, getOtpFetchOptions(state))\n        .then(getJsonAndCheckResponse)\n        .then(json => {\n          dispatch(routingResponse({ response: json, requestId, searchId }))\n          // If tracking is enabled, store locations and search after successful\n          // search is completed.\n          if (otpState.user.trackRecent) {\n            const { from, to } = otpState.currentQuery\n            if (!isStoredPlace(from)) {\n              dispatch(rememberPlace({ type: 'recent', location: formatRecentPlace(from) }))\n            }\n            if (!isStoredPlace(to)) {\n              dispatch(rememberPlace({ type: 'recent', location: formatRecentPlace(to) }))\n            }\n            dispatch(rememberSearch(formatRecentSearch(query, otpState)))\n          }\n        })\n        .catch(error => {\n          dispatch(routingError({ error, requestId, searchId }))\n        })\n      // Update OTP URL params if a new search. In other words, if we're\n      // performing a search based on query params taken from the URL after a back\n      // button press, we don't need to update the OTP URL.\n      // TODO: For old searches that we are re-running, should we be **replacing**\n      //  the URL params here (instead of **pushing** a new path to history like\n      //  what currently happens in updateOtpUrlParams)? That way we could ensure\n      //  that the path absolutely accurately reflects the app state.\n      const params = getUrlParams()\n      if (isNewSearch || params.ui_activeSearch !== searchId) {\n        dispatch(updateOtpUrlParams(otpState, searchId))\n      }\n\n      // Also fetch a non-realtime route.\n      //\n      // FIXME: The statement below may no longer apply with future work\n      // involving realtime info embedded in the OTP response.\n      // (That action records an entry again in the middleware.)\n      // For users who opted in to store trip request history,\n      // to avoid recording the same trip request twice in the middleware,\n      // only add the user Authorization token to the request\n      // when querying the non-realtime route.\n      //\n      // The advantage of using non-realtime route is that the middleware will be able to\n      // record and provide the theoretical itinerary summary without having to query OTP again.\n      // FIXME: Interestingly, and this could be from a side effect elsewhere,\n      // when a logged-in user refreshes the page, the trip request in the URL is not recorded again\n      // (state.user stays unpopulated until after this function is called).\n      //\n      const { user } = state\n      const storeTripHistory = user &&\n        user.loggedInUser &&\n        user.loggedInUser.storeTripHistory\n\n      fetch(constructRoutingQuery(otpState, true), getOtpFetchOptions(state, storeTripHistory))\n        .then(getJsonAndCheckResponse)\n        .then(json => {\n          // FIXME: This is only performed when ignoring realtimeupdates currently, just\n          // to ensure it is not repeated twice.\n          // FIXME: We should check that the mode combination actually has\n          // realtime (or maybe this is set in the config file) to determine\n          // whether this extra query to OTP is needed.\n          dispatch(nonRealtimeRoutingResponse({ response: json, searchId }))\n        })\n        .catch(error => {\n          console.error(error)\n          // do nothing\n        })\n    })\n  }\n}\n\nfunction getJsonAndCheckResponse (res) {\n  if (res.status >= 400) {\n    const error = new Error('Received error from server')\n    error.response = res\n    throw error\n  }\n  return res.json()\n}\n\n/**\n * This method determines the fetch options (including API key and Authorization headers) for the OTP API.\n * - If the OTP server is not the middleware server (standalone OTP server),\n *   an empty object is returned.\n * - If the OTP server is the same as the middleware server,\n *   then an object is returned with the following:\n *   - A middleware API key, if it has been set in the configuration (it is most likely required),\n *   - An Auth0 accessToken, when includeToken is true and a user is logged in (userState.loggedInUser is not null).\n * This method assumes JSON request bodies.)\n */\nfunction getOtpFetchOptions (state, includeToken = false) {\n  let apiBaseUrl, apiKey, token\n\n  const { api, persistence } = state.otp.config\n  if (persistence && persistence.otp_middleware) {\n    ({ apiBaseUrl, apiKey } = persistence.otp_middleware)\n  }\n\n  const isOtpServerSameAsMiddleware = apiBaseUrl === api.host\n  if (isOtpServerSameAsMiddleware) {\n    if (includeToken && state.user) {\n      const { accessToken, loggedInUser } = state.user\n      if (accessToken && loggedInUser) {\n        token = accessToken\n      }\n    }\n\n    return getSecureFetchOptions(token, apiKey)\n  } else {\n    return {}\n  }\n}\n\nfunction constructRoutingQuery (otpState, ignoreRealtimeUpdates, injectedParams = {}) {\n  const { config, currentQuery } = otpState\n  const routingType = currentQuery.routingType\n  // Check for routingType-specific API config; if none, use default API\n  const rt = config.routingTypes && config.routingTypes.find(rt => rt.key === routingType)\n  const api = (rt && rt.api) || config.api\n  const planEndpoint = `${api.host}${api.port\n    ? ':' + api.port\n    : ''}${api.path}/plan`\n  const params = {\n    ...getRoutingParams(currentQuery, ignoreRealtimeUpdates),\n    // Apply mode override, if specified (for batch routing).\n    ...injectedParams\n  }\n  return `${planEndpoint}?${qs.stringify(params, { arrayFormat: 'repeat' })}`\n}\n\nexport function getRoutingParams (query, config, ignoreRealtimeUpdates) {\n  const routingType = query.routingType\n  const isItinerary = routingType === 'ITINERARY'\n  let params = {}\n\n  // Start with the universe of OTP parameters defined in query-params.js:\n  queryParams\n    .filter(qp => {\n      // A given parameter is included in the request if all of the following:\n      // 1. Must apply to the active routing type (ITINERARY or PROFILE)\n      // 2. Must be included in the current user-defined query\n      // 3. Must pass the parameter's applicability test, if one is specified\n      return qp.routingTypes.indexOf(routingType) !== -1 &&\n        qp.name in query &&\n        (typeof qp.applicable !== 'function' || qp.applicable(query, config))\n    })\n    .forEach(qp => {\n      // Translate the applicable parameters according to their rewrite\n      // functions (if provided)\n      const rewriteFunction = isItinerary\n        ? qp.itineraryRewrite\n        : qp.profileRewrite\n      params = Object.assign(\n        params,\n        rewriteFunction\n          ? rewriteFunction(query[qp.name])\n          : { [qp.name]: query[qp.name] }\n      )\n    })\n\n  // Additional processing specific to ITINERARY mode\n  if (isItinerary) {\n    // override ignoreRealtimeUpdates if provided\n    if (typeof ignoreRealtimeUpdates === 'boolean') {\n      params.ignoreRealtimeUpdates = ignoreRealtimeUpdates\n    }\n\n    // check date/time validity; ignore both if either is invalid\n    const dateValid = moment(params.date, OTP_API_DATE_FORMAT).isValid()\n    const timeValid = moment(params.time, OTP_API_TIME_FORMAT).isValid()\n\n    if (!dateValid || !timeValid) {\n      delete params.time\n      delete params.date\n    }\n\n    // temp: set additional parameters for CAR_HAIL or CAR_RENT trips\n    if (\n      params.mode &&\n      (params.mode.includes('CAR_HAIL') || params.mode.includes('CAR_RENT'))\n    ) {\n      params.minTransitDistance = '50%'\n      // increase search timeout because these queries can take a while\n      params.searchTimeout = 10000\n    }\n\n    // set onlyTransitTrips for car rental searches\n    if (params.mode && params.mode.includes('CAR_RENT')) {\n      params.onlyTransitTrips = true\n    }\n\n  // Additional processing specific to PROFILE mode\n  } else {\n    // check start and end time validity; ignore both if either is invalid\n    const startTimeValid = moment(params.startTime, OTP_API_TIME_FORMAT).isValid()\n    const endTimeValid = moment(params.endTime, OTP_API_TIME_FORMAT).isValid()\n\n    if (!startTimeValid || !endTimeValid) {\n      delete params.startTimeValid\n      delete params.endTimeValid\n    }\n  }\n\n  // TODO: check that valid from/to locations are provided\n\n  // hack to add walking to driving/TNC trips\n  if (hasCar(params.mode)) {\n    params.mode += ',WALK'\n  }\n\n  return params\n}\n\n// Park and Ride location query\n\nexport const parkAndRideError = createAction('PARK_AND_RIDE_ERROR')\nexport const parkAndRideResponse = createAction('PARK_AND_RIDE_RESPONSE')\n\nexport function parkAndRideQuery (params) {\n  let endpoint = 'park_and_ride'\n  if (params && Object.keys(params).length > 0) {\n    endpoint += '?' + Object.keys(params).map(key => key + '=' + params[key]).join('&')\n  }\n  return createQueryAction(endpoint, parkAndRideResponse, parkAndRideError)\n}\n\n// bike rental station query\n\nexport const bikeRentalError = createAction('BIKE_RENTAL_ERROR')\nexport const bikeRentalResponse = createAction('BIKE_RENTAL_RESPONSE')\n\nexport function bikeRentalQuery (params) {\n  return createQueryAction('bike_rental', bikeRentalResponse, bikeRentalError)\n}\n\n// Car rental (e.g. car2go) locations lookup query\n\nexport const carRentalResponse = createAction('CAR_RENTAL_RESPONSE')\nexport const carRentalError = createAction('CAR_RENTAL_ERROR')\n\nexport function carRentalQuery (params) {\n  return createQueryAction('car_rental', carRentalResponse, carRentalError)\n}\n\n// Vehicle rental locations lookup query. For now, there are 3 seperate\n// \"vehicle\" rental endpoints - 1 for cars, 1 for bicycle rentals and another\n// for micromobility. In the future, the hope is to consolidate these 3\n// endpoints into one.\n\nexport const vehicleRentalResponse = createAction('VEHICLE_RENTAL_RESPONSE')\nexport const vehicleRentalError = createAction('VEHICLE_RENTAL_ERROR')\n\nexport function vehicleRentalQuery (params) {\n  return createQueryAction('vehicle_rental', vehicleRentalResponse, vehicleRentalError)\n}\n\n// Single stop lookup query\nconst findStopResponse = createAction('FIND_STOP_RESPONSE')\nconst findStopError = createAction('FIND_STOP_ERROR')\n\nexport function findStop (params) {\n  return createQueryAction(\n    `index/stops/${params.stopId}`,\n    findStopResponse,\n    findStopError,\n    {\n      serviceId: 'stops',\n      postprocess: (payload, dispatch) => {\n        dispatch(findRoutesAtStop(params.stopId))\n        dispatch(findStopTimesForStop(params))\n      },\n      noThrottle: true\n    }\n  )\n}\n\n// TODO: Optionally substitute GraphQL queries? Note: this is not currently\n// possible because gtfsdb (the alternative transit index used by TriMet) does not\n// support GraphQL queries.\n// export function findStop (params) {\n//   const query = `\n// query stopQuery($stopId: [String]) {\n//   stops (ids: $stopId) {\n//     id: gtfsId\n//     code\n//     name\n//     url\n//     lat\n//     lon\n//     stoptimesForPatterns {\n//       pattern {\n//         id: semanticHash\n//         route {\n//           id: gtfsId\n//           longName\n//           shortName\n//           sortOrder\n//         }\n//       }\n//       stoptimes {\n//         scheduledArrival\n//         realtimeArrival\n//         arrivalDelay\n//         scheduledDeparture\n//         realtimeDeparture\n//         departureDelay\n//         timepoint\n//         realtime\n//         realtimeState\n//         serviceDay\n//         headsign\n//       }\n//     }\n//   }\n// }\n// `\n//   return createGraphQLQueryAction(\n//     query,\n//     { stopId: params.stopId },\n//     findStopResponse,\n//     findStopError,\n//     {\n//       // find stop should not be throttled since it can make quite frequent\n//       // updates when fetching stop times for a stop\n//       noThrottle: true,\n//       serviceId: 'stops',\n//       rewritePayload: (payload) => {\n//         // convert pattern array to ID-mapped object\n//         const patterns = []\n//         const { stoptimesForPatterns, ...stop } = payload.data.stops[0]\n//         stoptimesForPatterns.forEach(obj => {\n//           const { pattern, stoptimes: stopTimes } = obj\n//           // It's possible that not all stop times for a pattern will share the\n//           // same headsign, but this is probably a minor edge case.\n//           const headsign = stopTimes[0]\n//             ? stopTimes[0].headsign\n//             : pattern.route.longName\n//           const patternIndex = patterns.findIndex(p =>\n//             p.headsign === headsign && pattern.route.id === p.route.id)\n//           if (patternIndex === -1) {\n//             patterns.push({ ...pattern, headsign, stopTimes })\n//           } else {\n//             patterns[patternIndex].stopTimes.push(...stopTimes)\n//           }\n//         })\n//         return {\n//           ...stop,\n//           patterns\n//         }\n//       }\n//     }\n//   )\n// }\n\n// Single trip lookup query\n\nexport const findTripResponse = createAction('FIND_TRIP_RESPONSE')\nexport const findTripError = createAction('FIND_TRIP_ERROR')\n\nexport function findTrip (params) {\n  return createQueryAction(\n    `index/trips/${params.tripId}`,\n    findTripResponse,\n    findTripError,\n    {\n      postprocess: (payload, dispatch) => {\n        dispatch(findStopsForTrip({tripId: params.tripId}))\n        dispatch(findStopTimesForTrip({tripId: params.tripId}))\n        dispatch(findGeometryForTrip({tripId: params.tripId}))\n      }\n    }\n  )\n}\n\n// Stops for trip query\n\nexport const findStopsForTripResponse = createAction('FIND_STOPS_FOR_TRIP_RESPONSE')\nexport const findStopsForTripError = createAction('FIND_STOPS_FOR_TRIP_ERROR')\n\nexport function findStopsForTrip (params) {\n  return createQueryAction(\n    `index/trips/${params.tripId}/stops`,\n    findStopsForTripResponse,\n    findStopsForTripError,\n    {\n      rewritePayload: (payload) => {\n        return {\n          tripId: params.tripId,\n          stops: payload\n        }\n      }\n    }\n  )\n}\n\n// Stop times for trip query\n\nexport const findStopTimesForTripResponse = createAction('FIND_STOP_TIMES_FOR_TRIP_RESPONSE')\nexport const findStopTimesForTripError = createAction('FIND_STOP_TIMES_FOR_TRIP_ERROR')\n\nexport function findStopTimesForTrip (params) {\n  return createQueryAction(\n    `index/trips/${params.tripId}/stoptimes`,\n    findStopTimesForTripResponse,\n    findStopTimesForTripError,\n    {\n      rewritePayload: (payload) => {\n        return {\n          tripId: params.tripId,\n          stopTimes: payload\n        }\n      },\n      noThrottle: true\n    }\n  )\n}\n\n// Geometry for trip query\n\nexport const findGeometryForTripResponse = createAction('FIND_GEOMETRY_FOR_TRIP_RESPONSE')\nexport const findGeometryForTripError = createAction('FIND_GEOMETRY_FOR_TRIP_ERROR')\n\nexport function findGeometryForTrip (params) {\n  const { tripId } = params\n  return createQueryAction(\n    `index/trips/${tripId}/geometry`,\n    findGeometryForTripResponse,\n    findGeometryForTripError,\n    {\n      rewritePayload: (payload) => ({ tripId, geometry: payload })\n    }\n  )\n}\n\nconst findStopTimesForStopResponse = createAction('FIND_STOP_TIMES_FOR_STOP_RESPONSE')\nconst findStopTimesForStopError = createAction('FIND_STOP_TIMES_FOR_STOP_ERROR')\n\n/**\n * Stop times for stop query (used in stop viewer).\n */\nexport function findStopTimesForStop (params) {\n  return function (dispatch, getState) {\n    let { stopId, ...otherParams } = params\n    // If other params not provided, fall back on defaults from stop viewer config.\n    const queryParams = { ...getStopViewerConfig(getState().otp), ...otherParams }\n    // If no start time is provided, pass in the current time. Note: this is not\n    // a required param by the back end, but if a value is not provided, the\n    // time defaults to the server's time, which can make it difficult to test\n    // scenarios when you may want to use a different date/time for your local\n    // testing environment.\n    if (!queryParams.startTime) {\n      const nowInSeconds = Math.floor((new Date()).getTime() / 1000)\n      queryParams.startTime = nowInSeconds\n    }\n    dispatch(createQueryAction(\n      `index/stops/${stopId}/stoptimes?${qs.stringify(queryParams)}`,\n      findStopTimesForStopResponse,\n      findStopTimesForStopError,\n      {\n        rewritePayload: (stopTimes) => {\n          return {\n            stopId,\n            stopTimes\n          }\n        },\n        noThrottle: true\n      }\n    ))\n  }\n}\n\n// Routes lookup query\n\nconst findRoutesResponse = createAction('FIND_ROUTES_RESPONSE')\nconst findRoutesError = createAction('FIND_ROUTES_ERROR')\n\nexport function findRoutes (params) {\n  return createQueryAction(\n    'index/routes',\n    findRoutesResponse,\n    findRoutesError,\n    {\n      serviceId: 'routes',\n      rewritePayload: (payload) => {\n        const routes = {}\n        payload.forEach(rte => { routes[rte.id] = rte })\n        return routes\n      }\n    }\n  )\n}\n\n// export function findRoutes (params) {\n//   const query = `\n// {\n//   routes {\n//     id: gtfsId\n//     color\n//     longName\n//     shortName\n//     mode\n//     type\n//     desc\n//     bikesAllowed\n//     sortOrder\n//     textColor\n//     url\n//     agency {\n//       id: gtfsId\n//       name\n//       url\n//     }\n//   }\n// }\n//   `\n//   return createGraphQLQueryAction(\n//     query,\n//     {},\n//     findRoutesResponse,\n//     findRoutesError,\n//     {\n//       serviceId: 'routes',\n//       rewritePayload: (payload) => {\n//         const routes = {}\n//         payload.data.routes.forEach(rte => { routes[rte.id] = rte })\n//         return routes\n//       }\n//     }\n//   )\n// }\n\n// Patterns for Route lookup query\n// TODO: replace with GraphQL query for route => patterns => geometry\nconst findPatternsForRouteResponse = createAction('FIND_PATTERNS_FOR_ROUTE_RESPONSE')\nconst findPatternsForRouteError = createAction('FIND_PATTERNS_FOR_ROUTE_ERROR')\n\n// Single Route lookup query\n\nexport const findRouteResponse = createAction('FIND_ROUTE_RESPONSE')\nexport const findRouteError = createAction('FIND_ROUTE_ERROR')\n\nexport function findRoute (params) {\n  return createQueryAction(\n    `index/routes/${params.routeId}`,\n    findRouteResponse,\n    findRouteError,\n    {\n      postprocess: (payload, dispatch) => {\n        // load patterns\n        dispatch(findPatternsForRoute({ routeId: params.routeId }))\n      },\n      noThrottle: true\n    }\n  )\n}\n\nexport function findPatternsForRoute (params) {\n  return createQueryAction(\n    `index/routes/${params.routeId}/patterns`,\n    findPatternsForRouteResponse,\n    findPatternsForRouteError,\n    {\n      rewritePayload: (payload) => {\n        // convert pattern array to ID-mapped object\n        const patterns = {}\n        payload.forEach(ptn => { patterns[ptn.id] = ptn })\n\n        return {\n          routeId: params.routeId,\n          patterns\n        }\n      },\n      postprocess: (payload, dispatch) => {\n        // load geometry for each pattern\n        payload.forEach(ptn => {\n          dispatch(findGeometryForPattern({\n            routeId: params.routeId,\n            patternId: ptn.id\n          }))\n        })\n      }\n    }\n  )\n}\n\n// Geometry for Pattern lookup query\n\nconst findGeometryForPatternResponse = createAction('FIND_GEOMETRY_FOR_PATTERN_RESPONSE')\nconst findGeometryForPatternError = createAction('FIND_GEOMETRY_FOR_PATTERN_ERROR')\n\nexport function findGeometryForPattern (params) {\n  return createQueryAction(\n    `index/patterns/${params.patternId}/geometry`,\n    findGeometryForPatternResponse,\n    findGeometryForPatternError,\n    {\n      rewritePayload: (payload) => {\n        return {\n          routeId: params.routeId,\n          patternId: params.patternId,\n          geometry: payload\n        }\n      }\n    }\n  )\n}\n\n// export function findRoute (params) {\n//   const query = `\n//   query routeQuery($routeId: [String]) {\n//     routes (ids: $routeId) {\n//       id: gtfsId\n//       patterns {\n//         id: semanticHash\n//         directionId\n//         headsign\n//         name\n//         semanticHash\n//         geometry {\n//           lat\n//           lon\n//         }\n//       }\n//     }\n//   }\n//   `\n//   return createGraphQLQueryAction(\n//     query,\n//     { routeId: params.routeId },\n//     findPatternsForRouteResponse,\n//     findPatternsForRouteError,\n//     {\n//       rewritePayload: (payload) => {\n//         // convert pattern array to ID-mapped object\n//         const patterns = {}\n//         payload.data.routes[0].patterns.forEach(ptn => {\n//           patterns[ptn.id] = {\n//             routeId: params.routeId,\n//             patternId: ptn.id,\n//             geometry: ptn.geometry\n//           }\n//         })\n//\n//         return {\n//           routeId: params.routeId,\n//           patterns\n//         }\n//       }\n//     }\n//   )\n// }\n\n// TNC ETA estimate lookup query\n\nexport const transportationNetworkCompanyEtaResponse = createAction('TNC_ETA_RESPONSE')\nexport const transportationNetworkCompanyEtaError = createAction('TNC_ETA_ERROR')\n\nexport function getTransportationNetworkCompanyEtaEstimate (params) {\n  const {companies, from} = params\n  return createQueryAction(\n    `transportation_network_company/eta_estimate?${qs.stringify({\n      companies,\n      from\n    })}`, // endpoint\n    transportationNetworkCompanyEtaResponse, // responseAction\n    transportationNetworkCompanyEtaError, // errorAction\n    {\n      rewritePayload: (payload) => {\n        return {\n          from,\n          estimates: payload.estimates\n        }\n      }\n    }\n  )\n}\n\n// TNC ride estimate lookup query\n\nexport const transportationNetworkCompanyRideResponse = createAction('TNC_RIDE_RESPONSE')\nexport const transportationNetworkCompanyRideError = createAction('TNC_RIDE_ERROR')\n\nexport function getTransportationNetworkCompanyRideEstimate (params) {\n  const {company, from, rideType, to} = params\n  return createQueryAction(\n    `transportation_network_company/ride_estimate?${qs.stringify({\n      company,\n      from,\n      rideType,\n      to\n    })}`, // endpoint\n    transportationNetworkCompanyRideResponse, // responseAction\n    transportationNetworkCompanyRideError, // errorAction\n    {\n      rewritePayload: (payload) => {\n        return {\n          company,\n          from,\n          rideEstimate: payload.rideEstimate,\n          to\n        }\n      }\n    }\n  )\n}\n\n// Nearby Stops Query\n\nconst receivedNearbyStopsResponse = createAction('NEARBY_STOPS_RESPONSE')\nconst receivedNearbyStopsError = createAction('NEARBY_STOPS_ERROR')\n\nexport function findNearbyStops (params) {\n  return createQueryAction(\n    `index/stops?${qs.stringify({radius: 1000, ...params})}`,\n    receivedNearbyStopsResponse,\n    receivedNearbyStopsError,\n    {\n      serviceId: 'stops',\n      rewritePayload: stops => {\n        if (stops) {\n          // Sort the stops by proximity\n          stops.forEach(stop => {\n            stop.distance = haversine(\n              { latitude: params.lat, longitude: params.lon },\n              { latitude: stop.lat, longitude: stop.lon }\n            )\n          })\n          stops.sort((a, b) => { return a.distance - b.distance })\n          if (params.max && stops.length > params.max) stops = stops.slice(0, params.max)\n        }\n        return {stops}\n      },\n      // retrieve routes for each stop\n      postprocess: (stops, dispatch, getState) => {\n        if (params.max && stops.length > params.max) stops = stops.slice(0, params.max)\n        stops.forEach(stop => dispatch(findRoutesAtStop(stop.id)))\n      }\n    }\n  )\n}\n\n// Routes at Stop query\n\nconst receivedRoutesAtStopResponse = createAction('ROUTES_AT_STOP_RESPONSE')\nconst receivedRoutesAtStopError = createAction('ROUTES_AT_STOP_ERROR')\n\nexport function findRoutesAtStop (stopId) {\n  return createQueryAction(\n    `index/stops/${stopId}/routes`,\n    receivedRoutesAtStopResponse,\n    receivedRoutesAtStopError,\n    {\n      serviceId: 'stops/routes',\n      rewritePayload: routes => ({ stopId, routes }),\n      noThrottle: true\n    }\n  )\n}\n\n// Stops within Bounding Box Query\n\nconst receivedStopsWithinBBoxResponse = createAction('STOPS_WITHIN_BBOX_RESPONSE')\nconst receivedStopsWithinBBoxError = createAction('STOPS_WITHIN_BBOX_ERROR')\n\nexport function findStopsWithinBBox (params) {\n  return createQueryAction(\n    `index/stops?${qs.stringify(params)}`,\n    receivedStopsWithinBBoxResponse,\n    receivedStopsWithinBBoxError,\n    {\n      serviceId: 'stops',\n      rewritePayload: stops => ({stops})\n    }\n  )\n}\n\nexport const clearStops = createAction('CLEAR_STOPS_OVERLAY')\n\nconst throttledUrls = {}\n\nfunction now () {\n  return (new Date()).getTime()\n}\n\nconst TEN_SECONDS = 10000\n\n// automatically clear throttled urls older than 10 seconds\nwindow.setInterval(() => {\n  Object.keys(throttledUrls).forEach(key => {\n    if (throttledUrls[key] < now() - TEN_SECONDS) {\n      delete throttledUrls[key]\n    }\n  })\n}, 1000)\n\n/**\n * Generic helper for constructing API queries. Automatically throttles queries\n * to url to no more than once per 10 seconds.\n *\n * @param {string} endpoint - The API endpoint path (does not include\n *   '../otp/routers/router_id/')\n * @param {Function} responseAction - Action to dispatch on a successful API\n *   response. Accepts payload object parameter.\n * @param {Function} errorAction - Function to invoke on API error response.\n *   Accepts error object parameter.\n * @param {Options} options - Any of the following optional settings:\n *   - rewritePayload: Function to be invoked to modify payload before being\n *       passed to responseAction. Accepts and returns payload object.\n *   - postprocess: Function to be invoked after responseAction is invoked.\n *       Accepts payload, dispatch, getState parameters.\n *   - serviceId: identifier for TransitIndex service used in\n *       alternateTransitIndex configuration.\n *   - fetchOptions: fetch options (e.g., method, body, headers).\n */\n\nfunction createQueryAction (endpoint, responseAction, errorAction, options = {}) {\n  return async function (dispatch, getState) {\n    const otpState = getState().otp\n    let url\n    if (options.serviceId && otpState.config.alternateTransitIndex &&\n      otpState.config.alternateTransitIndex.services.includes(options.serviceId)\n    ) {\n      console.log('Using alt service for ' + options.serviceId)\n      url = otpState.config.alternateTransitIndex.apiRoot + endpoint\n    } else {\n      const api = otpState.config.api\n      url = `${api.host}${api.port ? ':' + api.port : ''}${api.path}/${endpoint}`\n    }\n\n    if (!options.noThrottle) {\n      // don't make a request to a URL that has already seen the same request\n      // within the last 10 seconds\n      const throttleKey = options.fetchOptions\n        ? `${url}-${hash(options.fetchOptions)}`\n        : url\n      if (throttledUrls[throttleKey] && throttledUrls[throttleKey] > now() - TEN_SECONDS) {\n        // URL already had a request within last 10 seconds, warn and exit\n        console.warn(`Request throttled for url: ${url}`)\n        return\n      } else {\n        throttledUrls[throttleKey] = now()\n      }\n    }\n    let payload\n    try {\n      const response = await fetch(url, options.fetchOptions)\n      if (response.status >= 400) {\n        const error = new Error('Received error from server')\n        error.response = response\n        throw error\n      }\n      payload = await response.json()\n    } catch (err) {\n      return dispatch(errorAction(err))\n    }\n\n    if (typeof options.rewritePayload === 'function') {\n      dispatch(responseAction(options.rewritePayload(payload)))\n    } else {\n      dispatch(responseAction(payload))\n    }\n\n    if (typeof options.postprocess === 'function') {\n      options.postprocess(payload, dispatch, getState)\n    }\n  }\n}\n\n// TODO: Determine how we might be able to use GraphQL with the alternative\n// transit index. Currently this is not easily possible because the alternative\n// transit index does not have support for GraphQL and handling both Rest and\n// GraphQL queries could introduce potential difficulties for maintainers.\n// function createGraphQLQueryAction (query, variables, responseAction, errorAction, options) {\n//   const endpoint = `index/graphql`\n//   const fetchOptions = {\n//     method: 'POST',\n//     body: JSON.stringify({ query, variables }),\n//     headers: { 'Content-Type': 'application/json' }\n//   }\n//   return createQueryAction(\n//     endpoint,\n//     responseAction,\n//     errorAction,\n//     { ...options, fetchOptions }\n//   )\n// }\n\n/**\n * Update the browser/URL history with new parameters\n * NOTE: This has not been tested for profile-based journeys.\n */\nexport function setUrlSearch (params, replaceCurrent = false) {\n  return function (dispatch, getState) {\n    const base = getState().router.location.pathname\n    const path = `${base}?${qs.stringify(params, { arrayFormat: 'repeat' })}`\n    if (replaceCurrent) dispatch(replace(path))\n    else dispatch(push(path))\n  }\n}\n\n/**\n * Update the OTP Query parameters in the URL and ensure that the active search\n * is set correctly. Leaves any other existing URL parameters (e.g., UI) unchanged.\n */\nfunction updateOtpUrlParams (otpState, searchId) {\n  const {config, currentQuery} = otpState\n  // Get updated OTP params from current query.\n  const otpParams = getRoutingParams(currentQuery, config, true)\n  return function (dispatch, getState) {\n    const params = {}\n    // Get all URL params and ensure non-routing params (UI, sessionId) remain\n    // unchanged.\n    const urlParams = getUrlParams()\n    Object.keys(urlParams)\n      // If param is non-routing, add to params to keep the same after update.\n      .filter(key => key.indexOf('_') !== -1 || key === 'sessionId')\n      .forEach(key => { params[key] = urlParams[key] })\n    params.ui_activeSearch = searchId\n    // Assumes this is a new search and the active itinerary should be reset.\n    params.ui_activeItinerary = 0\n    // Merge in the provided OTP params and update the URL\n    dispatch(setUrlSearch(Object.assign(params, otpParams)))\n  }\n}\n"]}