{"version":3,"sources":["connected-transitive-overlay.js"],"names":["mapStateToProps","state","ownProps","activeSearch","otp","transitiveData","query","routingType","response","length","itins","visibleIndex","visibleItinerary","undefined","activeItinerary","coreUtils","map","itineraryToTransitive","visible","mapDispatchToProps","TransitiveCanvasOverlay"],"mappings":";;;;;;;AAAA;;AACA;;AACA;;AAEA;;;;AAEA;AAEA,MAAMA,eAAe,GAAG,CAACC,KAAD,EAAQC,QAAR,KAAqB;AAC3C,QAAMC,YAAY,GAAG,4BAAgBF,KAAK,CAACG,GAAtB,CAArB;AACA,MAAIC,cAAc,GAAG,IAArB;;AACA,MACEF,YAAY,IACZA,YAAY,CAACG,KAAb,CAAmBC,WAAnB,KAAmC,WADnC,IAEAJ,YAAY,CAACK,QAFb,IAGAL,YAAY,CAACK,QAAb,CAAsBC,MAAtB,GAA+B,CAJjC,EAKE;AACA;AACA,UAAMC,KAAK,GAAG,iCAAqBT,KAAK,CAACG,GAA3B,CAAd;AACA,UAAMO,YAAY,GAAGR,YAAY,CAACS,gBAAb,KAAkCC,SAAlC,IAA+CV,YAAY,CAACS,gBAAb,KAAkC,IAAjF,GACjBT,YAAY,CAACS,gBADI,GAEjBT,YAAY,CAACW,eAFjB,CAHA,CAMA;;AACA,UAAMF,gBAAgB,GAAGF,KAAK,CAACC,YAAD,CAAL,GAAsBD,KAAK,CAACC,YAAD,CAA3B,GAA4C,+BAAmBV,KAAK,CAACG,GAAzB,CAArE;AACA,QAAIQ,gBAAJ,EAAsBP,cAAc,GAAGU,mBAAUC,GAAV,CAAcC,qBAAd,CAAoCL,gBAApC,CAAjB;AACvB,GAdD,MAcO,IACLT,YAAY,IACZA,YAAY,CAACK,QADb,IAEAL,YAAY,CAACK,QAAb,CAAsBJ,GAHjB,EAIL;AACAC,IAAAA,cAAc,GAAGF,YAAY,CAACK,QAAb,CAAsBJ,GAAvC;AACD;;AAED,SAAO;AACLU,IAAAA,eAAe,EAAEX,YAAY,IAAIA,YAAY,CAACW,eADzC;AAELP,IAAAA,WAAW,EAAEJ,YAAY,IAAIA,YAAY,CAACG,KAA7B,IAAsCH,YAAY,CAACG,KAAb,CAAmBC,WAFjE;AAGLF,IAAAA,cAHK;AAILa,IAAAA,OAAO,EAAE;AAJJ,GAAP;AAMD,CA/BD;;AAiCA,MAAMC,kBAAkB,GAAG,EAA3B;;eAEe,yBAAQnB,eAAR,EAAyBmB,kBAAzB,EAA6CC,0BAA7C,C","sourcesContent":["import coreUtils from '@opentripplanner/core-utils'\nimport TransitiveCanvasOverlay from '@opentripplanner/transitive-overlay'\nimport { connect } from 'react-redux'\n\nimport { getActiveSearch, getActiveItinerary, getActiveItineraries } from '../../util/state'\n\n// connect to the redux store\n\nconst mapStateToProps = (state, ownProps) => {\n  const activeSearch = getActiveSearch(state.otp)\n  let transitiveData = null\n  if (\n    activeSearch &&\n    activeSearch.query.routingType === 'ITINERARY' &&\n    activeSearch.response &&\n    activeSearch.response.length > 0\n  ) {\n    // FIXME: This may need some simplification.\n    const itins = getActiveItineraries(state.otp)\n    const visibleIndex = activeSearch.visibleItinerary !== undefined && activeSearch.visibleItinerary !== null\n      ? activeSearch.visibleItinerary\n      : activeSearch.activeItinerary\n    // TODO: prevent itineraryToTransitive() from being called more than needed\n    const visibleItinerary = itins[visibleIndex] ? itins[visibleIndex] : getActiveItinerary(state.otp)\n    if (visibleItinerary) transitiveData = coreUtils.map.itineraryToTransitive(visibleItinerary)\n  } else if (\n    activeSearch &&\n    activeSearch.response &&\n    activeSearch.response.otp\n  ) {\n    transitiveData = activeSearch.response.otp\n  }\n\n  return {\n    activeItinerary: activeSearch && activeSearch.activeItinerary,\n    routingType: activeSearch && activeSearch.query && activeSearch.query.routingType,\n    transitiveData,\n    visible: true\n  }\n}\n\nconst mapDispatchToProps = {}\n\nexport default connect(mapStateToProps, mapDispatchToProps)(TransitiveCanvasOverlay)\n"]}