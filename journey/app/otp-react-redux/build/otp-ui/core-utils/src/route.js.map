{"version":3,"sources":["route.js"],"names":["getTransitOperatorFromId","feedId","transitOperators","find","transitOperator","id","getTransitOperatorFromOtpRoute","route","operatorId","split","toLowerCase","getSortValues","getterFn","a","b","aVal","bVal","modeComparatorValue","SUBWAY","TRAM","RAIL","GONDOLA","FERRY","CABLE_CAR","FUNICULAR","BUS","routeTypeComparatorValue","getRouteTypeComparatorValue","Error","mode","type","console","warn","routeTypeComparator","startsWithAlphabeticCharacter","val","length","firstCharCode","charCodeAt","alphabeticShortNameComparator","aStartsWithAlphabeticCharacter","shortName","bStartsWithAlphabeticCharacter","makeNumericValueComparator","objGetterFn","isNaN","makeStringValueComparator","getRouteSortOrderValue","undefined","makeMultiCriteriaSort","criteria","i","curCriteriaComparatorValue","routeComparator","obj","sortOrder","parseInt","longName"],"mappings":"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","sourcesContent":["/**\n * Looks up an operator from the provided configuration.\n * @param  {string} feedId - the feed ID, which can be obtained by splitting the\n *                            OTP route or stop ID by `:`\n * @param  {object} transitOperators - transitOperators from config.\n * @return {object} the operator for the specified feedId\n */\nexport function getTransitOperatorFromId(feedId, transitOperators) {\n  return (\n    transitOperators.find(transitOperator => transitOperator.id === feedId) ||\n    null\n  );\n}\n\n/** Looks up an operator from the provided configuration */\nexport function getTransitOperatorFromOtpRoute(route, transitOperators) {\n  if (!route.id) return null;\n  const operatorId = route.id.split(\":\")[0].toLowerCase();\n  return getTransitOperatorFromId(operatorId, transitOperators);\n}\n\n/**\n * The functions below are for enhanced route sorting functions for\n * the route viewer on OTP-react-redux.\n * They address route ordering issues discussed in\n * https://github.com/opentripplanner/otp-react-redux/pull/123 and\n * https://github.com/opentripplanner/otp-react-redux/pull/124.\n */\n\n/**\n * Gets the desired sort values according to an optional getter function. If the\n * getter function is not defined, the original sort values are returned.\n */\nfunction getSortValues(getterFn, a, b) {\n  let aVal;\n  let bVal;\n  if (typeof getterFn === \"function\") {\n    aVal = getterFn(a);\n    bVal = getterFn(b);\n  } else {\n    aVal = a;\n    bVal = b;\n  }\n  return { aVal, bVal };\n}\n\n// Lookup for the sort values associated with various OTP modes.\n// Note: JSDoc format not used to avoid bug in documentationjs.\n// https://github.com/documentationjs/documentation/issues/372\nconst modeComparatorValue = {\n  SUBWAY: 1,\n  TRAM: 2,\n  RAIL: 3,\n  GONDOLA: 4,\n  FERRY: 5,\n  CABLE_CAR: 6,\n  FUNICULAR: 7,\n  BUS: 8\n};\n\n// Lookup that maps route types to the OTP mode sort values.\n// Note: JSDoc format not used to avoid bug in documentationjs.\n// https://github.com/documentationjs/documentation/issues/372\nconst routeTypeComparatorValue = {\n  0: modeComparatorValue.TRAM, // - Tram, Streetcar, Light rail.\n  1: modeComparatorValue.SUBWAY, // - Subway, Metro.\n  2: modeComparatorValue.RAIL, // - Rail. Used for intercity or long-distance travel.\n  3: modeComparatorValue.BUS, // - Bus.\n  4: modeComparatorValue.FERRY, // - Ferry.\n  5: modeComparatorValue.CABLE_CAR, // - Cable tram.\n  6: modeComparatorValue.GONDOLA, // - Gondola, etc.\n  7: modeComparatorValue.FUNICULAR, // - Funicular.\n  // TODO: 11 and 12 are not a part of OTP as of 2019-02-14, but for now just\n  // associate them with bus/rail.\n  11: modeComparatorValue.BUS, // - Trolleybus.\n  12: modeComparatorValue.RAIL // - Monorail.\n};\n\n// Gets a comparator value for a given route's type (OTP mode).\n// Note: JSDoc format not used to avoid bug in documentationjs.\n// ttps://github.com/documentationjs/documentation/issues/372\nfunction getRouteTypeComparatorValue(route) {\n  // For some strange reason, the short route response in OTP returns the\n  // string-based modes, but the long route response returns the\n  // integer route type. This attempts to account for both of those cases.\n  if (!route) throw new Error(\"Route is undefined.\", route);\n  if (typeof modeComparatorValue[route.mode] !== \"undefined\") {\n    return modeComparatorValue[route.mode];\n  }\n  if (typeof routeTypeComparatorValue[route.type] !== \"undefined\") {\n    return routeTypeComparatorValue[route.type];\n  }\n  // Default the comparator value to a large number (placing the route at the\n  // end of the list).\n  console.warn(\"no mode/route type found for route\", route);\n  return 9999;\n}\n\n/**\n * Calculates the sort comparator value given two routes based off of route type\n * (OTP mode).\n */\nfunction routeTypeComparator(a, b) {\n  return getRouteTypeComparatorValue(a) - getRouteTypeComparatorValue(b);\n}\n\n/**\n * Determines whether a value is a string that starts with an alphabetic\n * ascii character.\n */\nfunction startsWithAlphabeticCharacter(val) {\n  if (typeof val === \"string\" && val.length > 0) {\n    const firstCharCode = val.charCodeAt(0);\n    return (\n      (firstCharCode >= 65 && firstCharCode <= 90) ||\n      (firstCharCode >= 97 && firstCharCode <= 122)\n    );\n  }\n  return false;\n}\n\n/**\n * Sorts routes based off of whether the shortName begins with an alphabetic\n * character. Routes with shortn that do start with an alphabetic character will\n * be prioritized over those that don't.\n */\nfunction alphabeticShortNameComparator(a, b) {\n  const aStartsWithAlphabeticCharacter = startsWithAlphabeticCharacter(\n    a.shortName\n  );\n  const bStartsWithAlphabeticCharacter = startsWithAlphabeticCharacter(\n    b.shortName\n  );\n\n  if (aStartsWithAlphabeticCharacter && bStartsWithAlphabeticCharacter) {\n    // both start with an alphabetic character, return equivalence\n    return 0;\n  }\n  // a does start with an alphabetic character, but b does not. Prioritize a\n  if (aStartsWithAlphabeticCharacter) return -1;\n  // b does start with an alphabetic character, but a does not. Prioritize b\n  if (bStartsWithAlphabeticCharacter) return 1;\n  // neither route has a shortName that starts with an alphabetic character.\n  // Return equivalence\n  return 0;\n}\n\n/**\n * Checks whether an appropriate comparison of numeric values can be made for\n * sorting purposes. If both values are not valid numbers according to the\n * isNaN check, then this function returns undefined which indicates that a\n * secondary sorting criteria should be used instead. If one value is valid and\n * the other is not, then the valid value will be given sorting priority. If\n * both values are valid numbers, the difference is obtained as the sort value.\n *\n * An optional argument can be provided which will be used to obtain the\n * comparison value from the comparison function arguments.\n *\n * IMPORTANT: the comparison values must be numeric values or at least be\n * attempted to be converted to numeric values! If one of the arguments is\n * something crazy like an empty string, unexpected behavior will occur because\n * JavaScript.\n *\n * @param  {function} [objGetterFn] An optional function to obtain the\n *  comparison value from the comparator function arguments\n */\nfunction makeNumericValueComparator(objGetterFn) {\n  /* Note: Using the global version of isNaN (the Number version behaves differently. */\n  /* eslint-disable no-restricted-globals */\n  return (a, b) => {\n    const { aVal, bVal } = getSortValues(objGetterFn, a, b);\n    // if both values aren't valid numbers, use the next sort criteria\n    if (isNaN(aVal) && isNaN(bVal)) return 0;\n    // b is a valid number, b gets priority\n    if (isNaN(aVal)) return 1;\n    // a is a valid number, a gets priority\n    if (isNaN(bVal)) return -1;\n    // a and b are valid numbers, return the sort value\n    return aVal - bVal;\n  };\n}\n\n/**\n * Create a comparator function that compares string values. The comparison\n * values feed to the sort comparator function are assumed to be objects that\n * will have either undefined, null or string values at the given key. If one\n * object has undefined, null or an empty string, but the other does have a\n * string with length > 0, then that string will get priority.\n *\n * @param  {function} [objGetterFn] An optional function to obtain the\n *  comparison value from the comparator function arguments\n */\nfunction makeStringValueComparator(objGetterFn) {\n  return (a, b) => {\n    const { aVal, bVal } = getSortValues(objGetterFn, a, b);\n    // both a and b are uncomparable strings, return equivalent value\n    if (!aVal && !bVal) return 0;\n    // a is not a comparable string, b gets priority\n    if (!aVal) return 1;\n    // b is not a comparable string, a gets priority\n    if (!bVal) return -1;\n    // a and b are comparable strings, return the sort value\n    if (aVal < bVal) return -1;\n    if (aVal > bVal) return 1;\n    return 0;\n  };\n}\n\n/**\n * OpenTripPlanner sets the routeSortOrder to -999 by default. So, if that value\n * is encountered, assume that it actually means that the routeSortOrder is not\n * set in the GTFS.\n *\n * See https://github.com/opentripplanner/OpenTripPlanner/issues/2938\n * Also see https://github.com/opentripplanner/otp-react-redux/issues/122\n */\nfunction getRouteSortOrderValue(val) {\n  return val === -999 ? undefined : val;\n}\n\n/**\n * Create a multi-criteria sort comparator function composed of other sort\n * comparator functions. Each comparator function will be ran in the order given\n * until a non-zero comparison value is obtained which is then immediately\n * returned. If all comparison functions return equivalance, then the values\n * are assumed to be equivalent.\n */\nfunction makeMultiCriteriaSort(...criteria) {\n  return (a, b) => {\n    for (let i = 0; i < criteria.length; i++) {\n      const curCriteriaComparatorValue = criteria[i](a, b);\n      // if the comparison objects are not equivalent, return the value obtained\n      // in this current criteria comparison\n      if (curCriteriaComparatorValue !== 0) {\n        return curCriteriaComparatorValue;\n      }\n    }\n    return 0;\n  };\n}\n\n/**\n * Compares routes for the purposes of sorting and displaying in a user\n * interface. Due to GTFS feeds having varying levels of data quality, a multi-\n * criteria sort is needed to account for various differences. The criteria\n * included here are each applied to the routes in the order listed. If a given\n * sort criterion yields equivalence (e.g., two routes have the short name\n * \"20\"), the comparator falls back onto the next sort criterion (e.g., long\n * name). If desired, the criteria of sorting based off of integer shortName can\n * be disabled. The sort operates on the following values (in order):\n *\n *  1. sortOrder. Routes that do not have a valid sortOrder will be placed\n *    beneath those that do.\n *  2. route type (OTP mode). See routeTypeComparator code for prioritization of\n *    route types.\n *  3. shortNames that begin with alphabetic characters. shortNames that do not\n *    start with alphabetic characters will be place beneath those that do.\n *  4. shortName as integer. shortNames that cannot be parsed as integers will\n *    be placed beneath those that are valid.\n *  5. shortName as string. Routes without shortNames will be placed beneath\n *    those with shortNames.\n *  6. longName as string.\n */\nexport const routeComparator = makeMultiCriteriaSort(\n  makeNumericValueComparator(obj => getRouteSortOrderValue(obj.sortOrder)),\n  routeTypeComparator,\n  alphabeticShortNameComparator,\n  makeNumericValueComparator(obj => parseInt(obj.shortName, 10)),\n  makeStringValueComparator(obj => obj.shortName),\n  makeStringValueComparator(obj => obj.longName)\n);\n"]}