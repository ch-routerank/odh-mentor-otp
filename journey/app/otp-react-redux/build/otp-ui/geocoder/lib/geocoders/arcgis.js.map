{"version":3,"sources":["arcgis.js"],"names":["Object","defineProperty","exports","value","default","_lonlat","_interopRequireDefault","require","_abstractGeocoder","obj","__esModule","ArcGISGeocoder","getLocationFromGeocodedFeature","feature","geometry","prototype","api","search","magicKey","text","then","response","firstFeature","features","location","fromCoordinates","coordinates","name","properties","label","rawGeocodedFeature","rewriteAutocompleteResponse","filter","isCollection","map","rewriteReverseResponse","query","lat","lon"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAC3CC,EAAAA,KAAK,EAAE;AADoC,CAA7C;AAGAD,OAAO,CAACE,OAAR,GAAkB,KAAK,CAAvB;;AAEA,IAAIC,OAAO,GAAGC,sBAAsB,CAACC,OAAO,CAAC,kBAAD,CAAR,CAApC;;AAEA,IAAIC,iBAAiB,GAAGF,sBAAsB,CAACC,OAAO,CAAC,qBAAD,CAAR,CAA9C;;AAEA,SAASD,sBAAT,CAAgCG,GAAhC,EAAqC;AAAE,SAAOA,GAAG,IAAIA,GAAG,CAACC,UAAX,GAAwBD,GAAxB,GAA8B;AAAEL,IAAAA,OAAO,EAAEK;AAAX,GAArC;AAAwD;AAE/F;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAME,cAAN,SAA6BH,iBAAiB,CAACJ,OAA/C,CAAuD;AACrD;AACF;AACA;AACA;AACA;AACEQ,EAAAA,8BAA8B,CAACC,OAAD,EAAU;AACtC;AACA;AACA,QAAIA,OAAO,CAACC,QAAZ,EAAsB;AACpB,aAAON,iBAAiB,CAACJ,OAAlB,CAA0BW,SAA1B,CAAoCH,8BAApC,CAAmEC,OAAnE,CAAP;AACD,KALqC,CAKpC;AACF;;;AAGA,WAAO,KAAKG,GAAL,CAASC,MAAT,CAAgB;AACrBC,MAAAA,QAAQ,EAAEL,OAAO,CAACK,QADG;AAErBC,MAAAA,IAAI,EAAEN,OAAO,CAACM;AAFO,KAAhB,EAGJC,IAHI,CAGCC,QAAQ,IAAI;AAClB,YAAMC,YAAY,GAAGD,QAAQ,CAACE,QAAT,CAAkB,CAAlB,CAArB;;AAEA,YAAMC,QAAQ,GAAGnB,OAAO,CAACD,OAAR,CAAgBqB,eAAhB,CAAgCH,YAAY,CAACR,QAAb,CAAsBY,WAAtD,CAAjB;;AAEAF,MAAAA,QAAQ,CAACG,IAAT,GAAgBL,YAAY,CAACM,UAAb,CAAwBC,KAAxC;AACAL,MAAAA,QAAQ,CAACM,kBAAT,GAA8BR,YAA9B;AACA,aAAOE,QAAP;AACD,KAXM,CAAP;AAYD;AACD;AACF;AACA;AACA;;;AAGEO,EAAAA,2BAA2B,CAACV,QAAD,EAAW;AACpC,WAAO;AACL;AACA;AACAE,MAAAA,QAAQ,EAAEF,QAAQ,CAACE,QAAT,CAAkBS,MAAlB,CAAyBnB,OAAO,IAAI,CAACA,OAAO,CAACoB,YAA7C,EAA2D;AAA3D,OACTC,GADS,CACLrB,OAAO,KAAK,EAAE,GAAGA,OAAL;AACfe,QAAAA,UAAU,EAAE;AACVC,UAAAA,KAAK,EAAEhB,OAAO,CAACM;AADL;AADG,OAAL,CADF;AAHL,KAAP;AAUD;AACD;AACF;AACA;AACA;;;AAGEgB,EAAAA,sBAAsB,CAACd,QAAD,EAAW;AAC/B,UAAM;AACJE,MAAAA,QADI;AAEJa,MAAAA;AAFI,QAGFf,QAHJ;AAIA,UAAM;AACJgB,MAAAA,GADI;AAEJC,MAAAA;AAFI,QAGFF,KAHJ;AAIA,UAAMd,YAAY,GAAGC,QAAQ,CAAC,CAAD,CAA7B;AACA,WAAO;AACLc,MAAAA,GADK;AAELC,MAAAA,GAFK;AAGLX,MAAAA,IAAI,EAAEL,YAAY,CAACM,UAAb,CAAwBC,KAHzB;AAILC,MAAAA,kBAAkB,EAAER;AAJf,KAAP;AAMD;;AApEoD;;AAwEvDpB,OAAO,CAACE,OAAR,GAAkBO,cAAlB","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _lonlat = _interopRequireDefault(require(\"@conveyal/lonlat\"));\n\nvar _abstractGeocoder = _interopRequireDefault(require(\"./abstract-geocoder\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Geocoder implementation for the ArcGIS geocoder.\n * See https://developers.arcgis.com/rest/geocode/api-reference/overview-world-geocoding-service.htm\n *\n * @extends Geocoder\n */\nclass ArcGISGeocoder extends _abstractGeocoder.default {\n  /**\n   * Using the given magicKey and text, perform a search query to get detailed\n   * address and GPS data. Return data in an application-specific location\n   * format.\n   */\n  getLocationFromGeocodedFeature(feature) {\n    // If feature was returned from 'search' query, it will already be\n    // structured properly.\n    if (feature.geometry) {\n      return _abstractGeocoder.default.prototype.getLocationFromGeocodedFeature(feature);\n    } // If feature returned from autocomplete, we need to use the magicKey to get\n    // the location's coordinates.\n\n\n    return this.api.search({\n      magicKey: feature.magicKey,\n      text: feature.text\n    }).then(response => {\n      const firstFeature = response.features[0];\n\n      const location = _lonlat.default.fromCoordinates(firstFeature.geometry.coordinates);\n\n      location.name = firstFeature.properties.label;\n      location.rawGeocodedFeature = firstFeature;\n      return location;\n    });\n  }\n  /**\n   * Rewrite an autocomplete response into an application specific data format.\n   * Also, filter out any results that are collections.\n   */\n\n\n  rewriteAutocompleteResponse(response) {\n    return {\n      // remove any autocomplete results that are collections\n      // (eg multiple Starbucks)\n      features: response.features.filter(feature => !feature.isCollection) // add label property so location-field can handle things ok\n      .map(feature => ({ ...feature,\n        properties: {\n          label: feature.text\n        }\n      }))\n    };\n  }\n  /**\n   * Rewrite the response into an application-specific data format using the\n   * first feature returned from the geocoder.\n   */\n\n\n  rewriteReverseResponse(response) {\n    const {\n      features,\n      query\n    } = response;\n    const {\n      lat,\n      lon\n    } = query;\n    const firstFeature = features[0];\n    return {\n      lat,\n      lon,\n      name: firstFeature.properties.label,\n      rawGeocodedFeature: firstFeature\n    };\n  }\n\n}\n\nexports.default = ArcGISGeocoder;"]}