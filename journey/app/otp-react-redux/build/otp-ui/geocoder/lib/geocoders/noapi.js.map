{"version":3,"sources":["noapi.js"],"names":["Object","defineProperty","exports","value","default","_lonlat","_interopRequireDefault","require","_abstractGeocoder","obj","__esModule","NoApiGeocoder","autocomplete","query","parseCoordinateString","text","reverse","lat","lon","point","roundGPSDecimal","feature","name","Promise","resolve","rawGeocodedFeature","search","string","geometry","coordinates","toCoordinates","fromLatFirstString","type","properties","label","e","features","number","roundFactor","Math","round"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAC3CC,EAAAA,KAAK,EAAE;AADoC,CAA7C;AAGAD,OAAO,CAACE,OAAR,GAAkB,KAAK,CAAvB;;AAEA,IAAIC,OAAO,GAAGC,sBAAsB,CAACC,OAAO,CAAC,kBAAD,CAAR,CAApC;;AAEA,IAAIC,iBAAiB,GAAGF,sBAAsB,CAACC,OAAO,CAAC,qBAAD,CAAR,CAA9C;;AAEA,SAASD,sBAAT,CAAgCG,GAAhC,EAAqC;AAAE,SAAOA,GAAG,IAAIA,GAAG,CAACC,UAAX,GAAwBD,GAAxB,GAA8B;AAAEL,IAAAA,OAAO,EAAEK;AAAX,GAArC;AAAwD;AAE/F;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAME,aAAN,SAA4BH,iBAAiB,CAACJ,OAA9C,CAAsD;AACpD;AACF;AACA;AACEQ,EAAAA,YAAY,CAACC,KAAD,EAAQ;AAClB,WAAO,KAAKC,qBAAL,CAA2BD,KAAK,CAACE,IAAjC,CAAP;AACD;AACD;AACF;AACA;;;AAGEC,EAAAA,OAAO,CAACH,KAAD,EAAQ;AACb,QAAI;AACFI,MAAAA,GADE;AAEFC,MAAAA;AAFE,QAGAL,KAAK,CAACM,KAHV;AAIAF,IAAAA,GAAG,GAAG,KAAKG,eAAL,CAAqBH,GAArB,CAAN;AACAC,IAAAA,GAAG,GAAG,KAAKE,eAAL,CAAqBF,GAArB,CAAN;AACA,UAAMG,OAAO,GAAG;AACdJ,MAAAA,GADc;AAEdC,MAAAA,GAFc;AAGdI,MAAAA,IAAI,EAAG,GAAEL,GAAI,KAAIC,GAAI;AAHP,KAAhB;AAKA,WAAOK,OAAO,CAACC,OAAR,CAAgB,EAAE,GAAGH,OAAL;AACrBI,MAAAA,kBAAkB,EAAEJ;AADC,KAAhB,CAAP;AAGD;AACD;AACF;AACA;;;AAGEK,EAAAA,MAAM,CAACb,KAAD,EAAQ;AACZ,WAAO,KAAKC,qBAAL,CAA2BD,KAAK,CAACE,IAAjC,CAAP;AACD;AACD;AACF;AACA;AACA;;;AAGED,EAAAA,qBAAqB,CAACa,MAAD,EAAS;AAC5B,QAAIN,OAAJ;;AAEA,QAAI;AACFA,MAAAA,OAAO,GAAG;AACRO,QAAAA,QAAQ,EAAE;AACRC,UAAAA,WAAW,EAAExB,OAAO,CAACD,OAAR,CAAgB0B,aAAhB,CAA8BzB,OAAO,CAACD,OAAR,CAAgB2B,kBAAhB,CAAmCJ,MAAnC,CAA9B,CADL;AAERK,UAAAA,IAAI,EAAE;AAFE,SADF;AAKRC,QAAAA,UAAU,EAAE;AACVC,UAAAA,KAAK,EAAEP;AADG;AALJ,OAAV;AASD,KAVD,CAUE,OAAOQ,CAAP,EAAU;AACV,aAAOZ,OAAO,CAACC,OAAR,CAAgB;AACrBY,QAAAA,QAAQ,EAAE;AADW,OAAhB,CAAP;AAGD;;AAED,WAAOb,OAAO,CAACC,OAAR,CAAgB;AACrBY,MAAAA,QAAQ,EAAE,CAACf,OAAD;AADW,KAAhB,CAAP;AAGD;;AAEDD,EAAAA,eAAe,CAACiB,MAAD,EAAS;AACtB,UAAMC,WAAW,GAAG,MAApB;AACA,WAAOC,IAAI,CAACC,KAAL,CAAWH,MAAM,GAAGC,WAApB,IAAmCA,WAA1C;AACD;;AArEmD;;AAyEtDpC,OAAO,CAACE,OAAR,GAAkBO,aAAlB","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _lonlat = _interopRequireDefault(require(\"@conveyal/lonlat\"));\n\nvar _abstractGeocoder = _interopRequireDefault(require(\"./abstract-geocoder\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * An implementation that doesn't use an API for geocoding. Merely allows\n * clicking on the map and finding GPS coordinates by typing them in.\n *\n * @extends Geocoder\n */\nclass NoApiGeocoder extends _abstractGeocoder.default {\n  /**\n   * Use coordinate string parser.\n   */\n  autocomplete(query) {\n    return this.parseCoordinateString(query.text);\n  }\n  /**\n   * Always return the lat/lon.\n   */\n\n\n  reverse(query) {\n    let {\n      lat,\n      lon\n    } = query.point;\n    lat = this.roundGPSDecimal(lat);\n    lon = this.roundGPSDecimal(lon);\n    const feature = {\n      lat,\n      lon,\n      name: `${lat}, ${lon}`\n    };\n    return Promise.resolve({ ...feature,\n      rawGeocodedFeature: feature\n    });\n  }\n  /**\n   * Use coordinate string parser.\n   */\n\n\n  search(query) {\n    return this.parseCoordinateString(query.text);\n  }\n  /**\n   * Attempt to parse the input as a GPS coordinate. If parseable, return a\n   * feature.\n   */\n\n\n  parseCoordinateString(string) {\n    let feature;\n\n    try {\n      feature = {\n        geometry: {\n          coordinates: _lonlat.default.toCoordinates(_lonlat.default.fromLatFirstString(string)),\n          type: \"Point\"\n        },\n        properties: {\n          label: string\n        }\n      };\n    } catch (e) {\n      return Promise.resolve({\n        features: []\n      });\n    }\n\n    return Promise.resolve({\n      features: [feature]\n    });\n  }\n\n  roundGPSDecimal(number) {\n    const roundFactor = 100000;\n    return Math.round(number * roundFactor) / roundFactor;\n  }\n\n}\n\nexports.default = NoApiGeocoder;"]}