{"version":3,"sources":["index.js"],"names":["getStationMarkerByColor","color","className","iconSize","popupAnchor","html","ReactDOMServer","renderToStaticMarkup","VehicleRentalOverlay","MapLayer","station","stationIsHub","configCompanies","getStationName","setLocation","props","stationName","location","lat","y","lon","x","name","bikesAvailable","spacesAvailable","symbolDef","strokeColor","fillColor","isFloatingBike","dockStrokeColor","id","pixels","renderPopupForStation","icon","floatingBikeIcon","pctFull","i","Math","round","hubIcons","markerIcon","mapSymbols","renderStationAsMarker","zoom","leaflet","map","getZoom","length","minZoom","maxZoom","type","renderStationAsCircle","renderStationAsHubAndFloatingBike","createLeafletElement","updateLeafletElement","startRefreshing","refreshVehicles","refreshTimer","setInterval","stopRefreshing","clearInterval","componentDidMount","companies","visible","console","warn","componentWillUnmount","componentDidUpdate","prevProps","render","stations","filteredStations","filter","networks","value","includes","renderStation","PropTypes","arrayOf","companyType","isRequired","string","func","vehicleRentalMapOverlaySymbolsType","stationType","bool","number","defaultProps","stationNetworks","isFloatingCar","isFloatingVehicle"],"mappings":"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","sourcesContent":["import { divIcon } from \"leaflet\";\nimport memoize from \"lodash.memoize\";\nimport * as BaseMapStyled from \"../../base-map/src/styled\";\nimport { getCompaniesLabelFromNetworks } from \"../../core-utils/src/itinerary\";\nimport {\n  companyType,\n  vehicleRentalMapOverlaySymbolsType,\n  stationType\n} from \"../../core-utils/src/types\";\nimport FromToLocationPicker from \"../../from-to-location-picker/src\";\nimport PropTypes from \"prop-types\";\nimport React from \"react\";\nimport ReactDOMServer from \"react-dom/server\";\nimport {\n  CircleMarker,\n  FeatureGroup,\n  Marker,\n  MapLayer,\n  Popup,\n  withLeaflet\n} from \"react-leaflet\";\n\nimport { floatingBikeIcon, hubIcons } from \"./bike-icons\";\nimport * as Styled from \"./styled\";\n\nconst getStationMarkerByColor = memoize(color =>\n  divIcon({\n    className: \"\",\n    iconSize: [11, 16],\n    popupAnchor: [0, -6],\n    html: ReactDOMServer.renderToStaticMarkup(\n      <Styled.StationMarker color={color} />\n    )\n  })\n);\n\n/**\n * This vehicle rental overlay can be used to render vehicle rentals of various\n * types. This layer can be configured to show different styles of markers at\n * different zoom levels.\n */\nclass VehicleRentalOverlay extends MapLayer {\n  createLeafletElement() {}\n\n  updateLeafletElement() {}\n\n  startRefreshing() {\n    const { refreshVehicles } = this.props;\n\n    // Create the timer only if refreshVehicles is a valid function.\n    if (typeof refreshVehicles === \"function\") {\n      // initial station retrieval\n      refreshVehicles();\n\n      // set up timer to refresh stations periodically\n      this.refreshTimer = setInterval(() => {\n        refreshVehicles();\n      }, 30000); // defaults to every 30 sec. TODO: make this configurable?\n    }\n  }\n\n  stopRefreshing() {\n    if (this.refreshTimer) clearInterval(this.refreshTimer);\n  }\n\n  componentDidMount() {\n    const { companies, mapSymbols, name, visible } = this.props;\n    if (visible) this.startRefreshing();\n    if (!mapSymbols)\n      console.warn(`No map symbols provided for layer ${name}`, companies);\n  }\n\n  componentWillUnmount() {\n    this.stopRefreshing();\n  }\n\n  componentDidUpdate(prevProps) {\n    if (!prevProps.visible && this.props.visible) {\n      this.startRefreshing();\n    } else if (prevProps.visible && !this.props.visible) {\n      this.stopRefreshing();\n    }\n  }\n\n  /**\n   * Render some popup html for a station. This contains custom logic for\n   * displaying rental vehicles in the TriMet MOD website that might not be\n   * applicable to other regions.\n   */\n  renderPopupForStation = (station, stationIsHub = false) => {\n    const { configCompanies, getStationName, setLocation } = this.props;\n    const stationName = getStationName(configCompanies, station);\n    const location = {\n      lat: station.y,\n      lon: station.x,\n      name: stationName\n    };\n    return (\n      <Popup>\n        <BaseMapStyled.MapOverlayPopup>\n          <BaseMapStyled.PopupTitle>{stationName}</BaseMapStyled.PopupTitle>\n\n          {/* render dock info if it is available */}\n          {stationIsHub && (\n            <BaseMapStyled.PopupRow>\n              <div>Available bikes: {station.bikesAvailable}</div>\n              <div>Available docks: {station.spacesAvailable}</div>\n            </BaseMapStyled.PopupRow>\n          )}\n\n          {/* Set as from/to toolbar */}\n          <BaseMapStyled.PopupRow>\n            <b>$_travel_$</b>\n            <FromToLocationPicker\n              location={location}\n              setLocation={setLocation}\n            />\n          </BaseMapStyled.PopupRow>\n        </BaseMapStyled.MapOverlayPopup>\n      </Popup>\n    );\n  };\n\n  renderStationAsCircle = (station, symbolDef) => {\n    let strokeColor = symbolDef.strokeColor || symbolDef.fillColor;\n    if (!station.isFloatingBike) {\n      strokeColor = symbolDef.dockStrokeColor || strokeColor;\n    }\n    return (\n      <CircleMarker\n        key={station.id}\n        center={[station.y, station.x]}\n        color={strokeColor}\n        fillColor={symbolDef.fillColor}\n        fillOpacity={1}\n        radius={symbolDef.pixels - (station.isFloatingBike ? 1 : 0)}\n        weight={1}\n      >\n        {this.renderPopupForStation(station)}\n      </CircleMarker>\n    );\n  };\n\n  renderStationAsHubAndFloatingBike = station => {\n    let icon;\n    if (station.isFloatingBike) {\n      icon = floatingBikeIcon;\n    } else {\n      const pctFull =\n        station.bikesAvailable /\n        (station.bikesAvailable + station.spacesAvailable);\n      const i = Math.round(pctFull * 9);\n      icon = hubIcons[i];\n    }\n    return (\n      <Marker icon={icon} key={station.id} position={[station.y, station.x]}>\n        {this.renderPopupForStation(station, !station.isFloatingBike)}\n      </Marker>\n    );\n  };\n\n  renderStationAsMarker = (station, symbolDef) => {\n    const color =\n      symbolDef && symbolDef.fillColor ? symbolDef.fillColor : \"gray\";\n    const markerIcon = getStationMarkerByColor(color);\n\n    return (\n      <Marker\n        icon={markerIcon}\n        key={station.id}\n        position={[station.y, station.x]}\n      >\n        {this.renderPopupForStation(station)}\n      </Marker>\n    );\n  };\n\n  renderStation = station => {\n    // render the station according to any map symbol configuration\n    const { mapSymbols } = this.props;\n\n    // no config set, just render a default marker\n    if (!mapSymbols) return this.renderStationAsMarker(station);\n\n    // get zoom to check which symbol to render\n    const zoom = this.props.leaflet.map.getZoom();\n\n    for (let i = 0; i < mapSymbols.length; i++) {\n      const symbolDef = mapSymbols[i];\n      if (symbolDef.minZoom <= zoom && symbolDef.maxZoom >= zoom) {\n        switch (symbolDef.type) {\n          case \"circle\":\n            return this.renderStationAsCircle(station, symbolDef);\n          case \"hubAndFloatingBike\":\n            return this.renderStationAsHubAndFloatingBike(station);\n          default:\n            return this.renderStationAsMarker(station, symbolDef);\n        }\n      }\n    }\n\n    // no matching symbol definition, render default marker\n    return this.renderStationAsMarker(station);\n  };\n\n  render() {\n    const { stations, companies } = this.props;\n    let filteredStations = stations;\n    if (companies) {\n      filteredStations = stations.filter(\n        station =>\n          station.networks.filter(value => companies.includes(value)).length > 0\n      );\n    }\n\n    if (!filteredStations || filteredStations.length === 0) {\n      return <FeatureGroup />;\n    }\n\n    return (\n      <FeatureGroup>{filteredStations.map(this.renderStation)}</FeatureGroup>\n    );\n  }\n}\n\nVehicleRentalOverlay.props = {\n  /**\n   * The entire companies config array.\n   */\n  configCompanies: PropTypes.arrayOf(companyType.isRequired).isRequired,\n  /**\n   * A list of companies that are applicable to just this instance of the\n   * overlay.\n   */\n  companies: PropTypes.arrayOf(PropTypes.string.isRequired),\n  /**\n   * An optional custom function to create a string name of a particular vehicle\n   * rental station. This function takes two arguments of the configCompanies\n   * prop and a vehicle rental station. The function must return a string.\n   */\n  getStationName: PropTypes.func,\n  /**\n   * A configuration of what map markers or symbols to show at various zoom\n   * levels.\n   */\n  mapSymbols: vehicleRentalMapOverlaySymbolsType,\n  /**\n   * If specified, a function that will be triggered every 30 seconds whenever this layer is\n   * visible.\n   */\n  refreshVehicles: PropTypes.func,\n  /**\n   * A callback for when a user clicks on setting this stop as either the from\n   * or to location of a new search.\n   *\n   * This will be dispatched with the following argument:\n   *\n   * ```js\n   *  {\n   *    location: {\n   *      lat: number,\n   *      lon: number,\n   *      name: string\n   *    },\n   *    locationType: \"from\" or \"to\"\n   *  }\n   * ```\n   */\n  setLocation: PropTypes.func.isRequired,\n  /**\n   * A list of the vehicle rental stations specific to this overlay instance.\n   */\n  stations: PropTypes.arrayOf(stationType),\n  /**\n   * Whether the overlay is currently visible.\n   */\n  visible: PropTypes.bool,\n  /**\n   * The current map zoom level.\n   */\n  zoom: PropTypes.number.isRequired\n};\n\nVehicleRentalOverlay.defaultProps = {\n  getStationName: (configCompanies, station) => {\n    const stationNetworks = getCompaniesLabelFromNetworks(\n      station.networks,\n      configCompanies\n    );\n    let stationName = station.name || station.id;\n    if (station.isFloatingBike) {\n      stationName = `Free-floating bike: ${stationName}`;\n    } else if (station.isFloatingCar) {\n      stationName = `${stationNetworks} ${stationName}`;\n    } else if (station.isFloatingVehicle) {\n      // assumes that all floating vehicles are E-scooters\n      stationName = `${stationNetworks} E-scooter`;\n    }\n    return stationName;\n  },\n  mapSymbols: null,\n  refreshVehicles: null,\n  stations: [],\n  visible: false\n};\n\nexport default withLeaflet(VehicleRentalOverlay);\n"]}