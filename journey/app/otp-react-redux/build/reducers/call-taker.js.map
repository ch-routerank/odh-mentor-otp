{"version":3,"sources":["call-taker.js"],"names":["randId","coreUtils","storage","UPPER_RIGHT_CORNER","x","y","FETCH_STATUS","UNFETCHED","FETCHING","FETCHED","ERROR","createCallTakerReducer","initialState","activeCall","callHistory","position","visible","calls","status","data","fieldTrips","session","state","action","type","newCall","startTime","id","searches","$set","payload","sort","a","b","endTime","callId","queries","index","findIndex","call","$push","searchId","username","sessionId","window","alert"],"mappings":"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","sourcesContent":["import coreUtils from '@opentripplanner/core-utils'\nimport update from 'immutability-helper'\nimport moment from 'moment'\n\nimport {getTimestamp} from '../util/state'\n\nconst { randId } = coreUtils.storage\n\nconst UPPER_RIGHT_CORNER = {x: 604, y: 53}\n\nconst FETCH_STATUS = {\n  UNFETCHED: 0,\n  FETCHING: 1,\n  FETCHED: 2,\n  ERROR: -1\n}\n\nfunction createCallTakerReducer () {\n  const initialState = {\n    activeCall: null,\n    callHistory: {\n      position: UPPER_RIGHT_CORNER,\n      visible: false,\n      calls: {\n        status: FETCH_STATUS.UNFETCHED,\n        data: []\n      }\n    },\n    fieldTrips: [],\n    session: null\n  }\n  return (state = initialState, action) => {\n    switch (action.type) {\n      case 'BEGIN_CALL': {\n        const newCall = {\n          startTime: getTimestamp(),\n          id: randId(),\n          searches: []\n        }\n        // Initialize new call and show call history window.\n        return update(state, {\n          activeCall: { $set: newCall },\n          callHistory: { visible: { $set: true } }\n        })\n      }\n      case 'REQUESTING_CALLS': {\n        return update(state, {\n          callHistory: { calls: { status: { $set: FETCH_STATUS.FETCHING } } }\n        })\n      }\n      case 'RECEIVED_CALLS': {\n        const data = action.payload.calls\n        const calls = {\n          status: FETCH_STATUS.FETCHED,\n          data: data.sort((a, b) => moment(b.endTime) - moment(a.endTime))\n        }\n        return update(state, {\n          callHistory: { calls: { $set: calls } }\n        })\n      }\n      case 'RECEIVED_QUERIES': {\n        const {callId, queries} = action.payload\n        const {data} = state.callHistory.calls\n        const index = data.findIndex(call => call.id === callId)\n        const call = {...data[index], queries}\n        return update(state, {\n          callHistory: { calls: { data: { [index]: { $set: call } } } }\n        })\n      }\n      case 'ROUTING_RESPONSE': {\n        // If call is in progress, record search ID when a routing response is\n        // fulfilled.\n        // TODO: How should we handle routing errors.\n        if (state.activeCall) {\n          return update(state, {\n            activeCall: { searches: { $push: [action.payload.searchId] } }\n          })\n        }\n        // Otherwise, ignore.\n        return state\n      }\n      case 'STORE_SESSION': {\n        const {session} = action.payload\n        if (!session || !session.username) {\n          const sessionId = session ? session.sessionId : 'N/A'\n          // Session is invalid if username is missing.\n          window.alert(`Session ID ${sessionId} is invalid!`)\n          // TODO: Should we return to URL_ROOT at this point?\n          return update(state, { session: { $set: null } })\n        }\n        return update(state, { session: { $set: session } })\n      }\n      case 'TOGGLE_CALL_HISTORY': {\n        return update(state, {\n          callHistory: { visible: { $set: !state.callHistory.visible } }\n        })\n      }\n      case 'END_CALL': {\n        return update(state, {\n          activeCall: { $set: null }\n        })\n      }\n      default:\n        return state\n    }\n  }\n}\n\nexport default createCallTakerReducer\n"]}