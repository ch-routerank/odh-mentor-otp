{"version":3,"sources":["api.js"],"names":["fetch","require","hasCar","coreUtils","itinerary","query","getTripOptionsFromQuery","getUrlParams","randId","storage","time","OTP_API_DATE_FORMAT","OTP_API_TIME_FORMAT","nonRealtimeRoutingResponse","routingRequest","routingResponse","routingError","toggleTracking","rememberSearch","forgetSearch","formatRecentPlace","place","type","icon","id","timestamp","Date","getTime","formatRecentSearch","url","otpState","currentQuery","isStoredPlace","indexOf","getActiveItinerary","searches","activeItinerary","routingType","urlParams","hasSearches","Object","keys","length","ui_activeItinerary","routingQuery","searchId","dispatch","getState","state","otp","isNewSearch","console","warn","iterations","config","modes","combinations","map","mode","params","pending","forEach","injectedParams","i","requestId","constructRoutingQuery","getOtpFetchOptions","then","getJsonAndCheckResponse","json","response","user","trackRecent","from","to","location","catch","error","ui_activeSearch","updateOtpUrlParams","storeTripHistory","loggedInUser","res","status","Error","includeToken","apiBaseUrl","apiKey","token","api","persistence","otp_middleware","isOtpServerSameAsMiddleware","host","accessToken","ignoreRealtimeUpdates","rt","routingTypes","find","key","planEndpoint","port","path","getRoutingParams","qs","stringify","arrayFormat","isItinerary","queryParams","filter","qp","name","applicable","rewriteFunction","itineraryRewrite","profileRewrite","assign","dateValid","date","isValid","timeValid","includes","minTransitDistance","searchTimeout","onlyTransitTrips","startTimeValid","startTime","endTimeValid","endTime","parkAndRideError","parkAndRideResponse","parkAndRideQuery","endpoint","join","createQueryAction","bikeRentalError","bikeRentalResponse","bikeRentalQuery","carRentalResponse","carRentalError","carRentalQuery","vehicleRentalResponse","vehicleRentalError","vehicleRentalQuery","findStopResponse","findStopError","findStop","stopId","serviceId","postprocess","payload","findRoutesAtStop","findStopTimesForStop","noThrottle","findTripResponse","findTripError","findTrip","tripId","findStopsForTrip","findStopTimesForTrip","findGeometryForTrip","findStopsForTripResponse","findStopsForTripError","rewritePayload","stops","findStopTimesForTripResponse","findStopTimesForTripError","stopTimes","findGeometryForTripResponse","findGeometryForTripError","geometry","findStopTimesForStopResponse","findStopTimesForStopError","otherParams","nowInSeconds","Math","floor","findRoutesResponse","findRoutesError","findRoutes","routes","rte","findPatternsForRouteResponse","findPatternsForRouteError","findRouteResponse","findRouteError","findRoute","routeId","findPatternsForRoute","patterns","ptn","findGeometryForPattern","patternId","findGeometryForPatternResponse","findGeometryForPatternError","transportationNetworkCompanyEtaResponse","transportationNetworkCompanyEtaError","getTransportationNetworkCompanyEtaEstimate","companies","estimates","transportationNetworkCompanyRideResponse","transportationNetworkCompanyRideError","getTransportationNetworkCompanyRideEstimate","company","rideType","rideEstimate","receivedNearbyStopsResponse","receivedNearbyStopsError","findNearbyStops","radius","stop","distance","latitude","lat","longitude","lon","sort","a","b","max","slice","receivedRoutesAtStopResponse","receivedRoutesAtStopError","receivedStopsWithinBBoxResponse","receivedStopsWithinBBoxError","findStopsWithinBBox","clearStops","throttledUrls","now","TEN_SECONDS","window","setInterval","responseAction","errorAction","options","alternateTransitIndex","services","log","apiRoot","throttleKey","fetchOptions","setUrlSearch","replaceCurrent","base","router","pathname","otpParams"],"mappings":"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","sourcesContent":["/* globals fetch */\nimport { push, replace } from 'connected-react-router'\nimport haversine from 'haversine'\nimport moment from 'moment'\nimport hash from 'object-hash'\nimport coreUtils from '@opentripplanner/core-utils'\nimport queryParams from '@opentripplanner/core-utils/lib/query-params'\nimport { createAction } from 'redux-actions'\nimport qs from 'qs'\n\nimport { rememberPlace } from './map'\nimport { getStopViewerConfig, queryIsValid } from '../util/state'\nimport { getSecureFetchOptions } from '../util/middleware'\n\nif (typeof (fetch) === 'undefined') require('isomorphic-fetch')\n\nconst { hasCar } = coreUtils.itinerary\nconst { getTripOptionsFromQuery, getUrlParams } = coreUtils.query\nconst { randId } = coreUtils.storage\nconst { OTP_API_DATE_FORMAT, OTP_API_TIME_FORMAT } = coreUtils.time\n\n// Generic API actions\n\nexport const nonRealtimeRoutingResponse = createAction('NON_REALTIME_ROUTING_RESPONSE')\nexport const routingRequest = createAction('ROUTING_REQUEST')\nexport const routingResponse = createAction('ROUTING_RESPONSE')\nexport const routingError = createAction('ROUTING_ERROR')\nexport const toggleTracking = createAction('TOGGLE_TRACKING')\nexport const rememberSearch = createAction('REMEMBER_SEARCH')\nexport const forgetSearch = createAction('FORGET_SEARCH')\n\nfunction formatRecentPlace (place) {\n  return {\n    ...place,\n    type: 'recent',\n    icon: 'clock-o',\n    id: `recent-${randId()}`,\n    timestamp: new Date().getTime()\n  }\n}\n\nfunction formatRecentSearch (url, otpState) {\n  return {\n    query: getTripOptionsFromQuery(otpState.currentQuery, true),\n    url,\n    id: randId(),\n    timestamp: new Date().getTime()\n  }\n}\n\nfunction isStoredPlace (place) {\n  return ['home', 'work', 'suggested', 'stop'].indexOf(place.type) !== -1\n}\n\n/**\n * Compute the initial activeItinerary. If this is the first search of\n * session (i.e. searches lookup is empty/null) AND an activeItinerary ID\n * is specified in URL parameters, use that ID. Otherwise, use null/0.\n */\nfunction getActiveItinerary (otpState) {\n  const {currentQuery, searches} = otpState\n  let activeItinerary = currentQuery.routingType === 'ITINERARY' ? 0 : null\n  // We cannot use window.history.state here to check for the active\n  // itinerary param because it is unreliable in some states (e.g.,\n  // when the print layout component first loads).\n  const urlParams = getUrlParams()\n  const hasSearches = !searches || Object.keys(searches).length === 0\n  if (hasSearches && urlParams.ui_activeItinerary) {\n    activeItinerary = +urlParams.ui_activeItinerary\n  }\n  return activeItinerary\n}\n\n/**\n * Send a routing query to the OTP backend.\n *\n * NOTE: We need a random ID so that when a user reloads the page (clearing the\n * state), performs searches, and presses back to load previous searches\n * that are no longer contained in the state we don't confuse the search IDs\n * with search IDs from the new session. If we were to use sequential numbers\n * as IDs, we would run into this problem.\n */\nexport function routingQuery (searchId = null) {\n  return async function (dispatch, getState) {\n    // FIXME: batchId is searchId for now.\n    const state = getState()\n    const otpState = state.otp\n\n    const isNewSearch = !searchId\n    if (isNewSearch) searchId = randId()\n    // Don't permit a routing query if the query is invalid\n    if (!queryIsValid(otpState)) {\n      console.warn('Query is invalid. Aborting routing query', otpState.currentQuery)\n      return\n    }\n    const activeItinerary = getActiveItinerary(otpState)\n    const routingType = otpState.currentQuery.routingType\n    // For multiple mode combinations, gather injected params from config/query.\n    // Otherwise, inject nothing (rely on what's in current query) and perform\n    // one iteration.\n    const iterations = otpState.config.modes && otpState.config.modes.combinations\n      ? otpState.config.modes.combinations.map(({mode, params}) => ({mode, ...params}))\n      : [{}]\n    dispatch(routingRequest({ activeItinerary, routingType, searchId, pending: iterations.length }))\n    iterations.forEach((injectedParams, i) => {\n      const requestId = randId()\n      // fetch a realtime route\n      const query = constructRoutingQuery(otpState, false, injectedParams)\n      fetch(query, getOtpFetchOptions(state))\n        .then(getJsonAndCheckResponse)\n        .then(json => {\n          dispatch(routingResponse({ response: json, requestId, searchId }))\n          // If tracking is enabled, store locations and search after successful\n          // search is completed.\n          if (otpState.user.trackRecent) {\n            const { from, to } = otpState.currentQuery\n            if (!isStoredPlace(from)) {\n              dispatch(rememberPlace({ type: 'recent', location: formatRecentPlace(from) }))\n            }\n            if (!isStoredPlace(to)) {\n              dispatch(rememberPlace({ type: 'recent', location: formatRecentPlace(to) }))\n            }\n            dispatch(rememberSearch(formatRecentSearch(query, otpState)))\n          }\n        })\n        .catch(error => {\n          dispatch(routingError({ error, requestId, searchId }))\n        })\n      // Update OTP URL params if a new search. In other words, if we're\n      // performing a search based on query params taken from the URL after a back\n      // button press, we don't need to update the OTP URL.\n      // TODO: For old searches that we are re-running, should we be **replacing**\n      //  the URL params here (instead of **pushing** a new path to history like\n      //  what currently happens in updateOtpUrlParams)? That way we could ensure\n      //  that the path absolutely accurately reflects the app state.\n      const params = getUrlParams()\n      if (isNewSearch || params.ui_activeSearch !== searchId) {\n        dispatch(updateOtpUrlParams(otpState, searchId))\n      }\n\n      // Also fetch a non-realtime route.\n      //\n      // FIXME: The statement below may no longer apply with future work\n      // involving realtime info embedded in the OTP response.\n      // (That action records an entry again in the middleware.)\n      // For users who opted in to store trip request history,\n      // to avoid recording the same trip request twice in the middleware,\n      // only add the user Authorization token to the request\n      // when querying the non-realtime route.\n      //\n      // The advantage of using non-realtime route is that the middleware will be able to\n      // record and provide the theoretical itinerary summary without having to query OTP again.\n      // FIXME: Interestingly, and this could be from a side effect elsewhere,\n      // when a logged-in user refreshes the page, the trip request in the URL is not recorded again\n      // (state.user stays unpopulated until after this function is called).\n      //\n      const { user } = state\n      const storeTripHistory = user &&\n        user.loggedInUser &&\n        user.loggedInUser.storeTripHistory\n\n      fetch(constructRoutingQuery(otpState, true), getOtpFetchOptions(state, storeTripHistory))\n        .then(getJsonAndCheckResponse)\n        .then(json => {\n          // FIXME: This is only performed when ignoring realtimeupdates currently, just\n          // to ensure it is not repeated twice.\n          // FIXME: We should check that the mode combination actually has\n          // realtime (or maybe this is set in the config file) to determine\n          // whether this extra query to OTP is needed.\n          dispatch(nonRealtimeRoutingResponse({ response: json, searchId }))\n        })\n        .catch(error => {\n          console.error(error)\n          // do nothing\n        })\n    })\n  }\n}\n\nfunction getJsonAndCheckResponse (res) {\n  if (res.status >= 400) {\n    const error = new Error('Received error from server')\n    error.response = res\n    throw error\n  }\n  return res.json()\n}\n\n/**\n * This method determines the fetch options (including API key and Authorization headers) for the OTP API.\n * - If the OTP server is not the middleware server (standalone OTP server),\n *   an empty object is returned.\n * - If the OTP server is the same as the middleware server,\n *   then an object is returned with the following:\n *   - A middleware API key, if it has been set in the configuration (it is most likely required),\n *   - An Auth0 accessToken, when includeToken is true and a user is logged in (userState.loggedInUser is not null).\n * This method assumes JSON request bodies.)\n */\nfunction getOtpFetchOptions (state, includeToken = false) {\n  let apiBaseUrl, apiKey, token\n\n  const { api, persistence } = state.otp.config\n  if (persistence && persistence.otp_middleware) {\n    ({ apiBaseUrl, apiKey } = persistence.otp_middleware)\n  }\n\n  const isOtpServerSameAsMiddleware = apiBaseUrl === api.host\n  if (isOtpServerSameAsMiddleware) {\n    if (includeToken && state.user) {\n      const { accessToken, loggedInUser } = state.user\n      if (accessToken && loggedInUser) {\n        token = accessToken\n      }\n    }\n\n    return getSecureFetchOptions(token, apiKey)\n  } else {\n    return {}\n  }\n}\n\nfunction constructRoutingQuery (otpState, ignoreRealtimeUpdates, injectedParams = {}) {\n  const { config, currentQuery } = otpState\n  const routingType = currentQuery.routingType\n  // Check for routingType-specific API config; if none, use default API\n  const rt = config.routingTypes && config.routingTypes.find(rt => rt.key === routingType)\n  const api = (rt && rt.api) || config.api\n  const planEndpoint = `${api.host}${api.port\n    ? ':' + api.port\n    : ''}${api.path}/plan`\n  const params = {\n    ...getRoutingParams(currentQuery, ignoreRealtimeUpdates),\n    // Apply mode override, if specified (for batch routing).\n    ...injectedParams\n  }\n  return `${planEndpoint}?${qs.stringify(params, { arrayFormat: 'repeat' })}`\n}\n\nexport function getRoutingParams (query, config, ignoreRealtimeUpdates) {\n  const routingType = query.routingType\n  const isItinerary = routingType === 'ITINERARY'\n  let params = {}\n\n  // Start with the universe of OTP parameters defined in query-params.js:\n  queryParams\n    .filter(qp => {\n      // A given parameter is included in the request if all of the following:\n      // 1. Must apply to the active routing type (ITINERARY or PROFILE)\n      // 2. Must be included in the current user-defined query\n      // 3. Must pass the parameter's applicability test, if one is specified\n      return qp.routingTypes.indexOf(routingType) !== -1 &&\n        qp.name in query &&\n        (typeof qp.applicable !== 'function' || qp.applicable(query, config))\n    })\n    .forEach(qp => {\n      // Translate the applicable parameters according to their rewrite\n      // functions (if provided)\n      const rewriteFunction = isItinerary\n        ? qp.itineraryRewrite\n        : qp.profileRewrite\n      params = Object.assign(\n        params,\n        rewriteFunction\n          ? rewriteFunction(query[qp.name])\n          : { [qp.name]: query[qp.name] }\n      )\n    })\n\n  // Additional processing specific to ITINERARY mode\n  if (isItinerary) {\n    // override ignoreRealtimeUpdates if provided\n    if (typeof ignoreRealtimeUpdates === 'boolean') {\n      params.ignoreRealtimeUpdates = ignoreRealtimeUpdates\n    }\n\n    // check date/time validity; ignore both if either is invalid\n    const dateValid = moment(params.date, OTP_API_DATE_FORMAT).isValid()\n    const timeValid = moment(params.time, OTP_API_TIME_FORMAT).isValid()\n\n    if (!dateValid || !timeValid) {\n      delete params.time\n      delete params.date\n    }\n\n    // temp: set additional parameters for CAR_HAIL or CAR_RENT trips\n    if (\n      params.mode &&\n      (params.mode.includes('CAR_HAIL') || params.mode.includes('CAR_RENT'))\n    ) {\n      params.minTransitDistance = '50%'\n      // increase search timeout because these queries can take a while\n      params.searchTimeout = 10000\n    }\n\n    // set onlyTransitTrips for car rental searches\n    if (params.mode && params.mode.includes('CAR_RENT')) {\n      params.onlyTransitTrips = true\n    }\n\n  // Additional processing specific to PROFILE mode\n  } else {\n    // check start and end time validity; ignore both if either is invalid\n    const startTimeValid = moment(params.startTime, OTP_API_TIME_FORMAT).isValid()\n    const endTimeValid = moment(params.endTime, OTP_API_TIME_FORMAT).isValid()\n\n    if (!startTimeValid || !endTimeValid) {\n      delete params.startTimeValid\n      delete params.endTimeValid\n    }\n  }\n\n  // TODO: check that valid from/to locations are provided\n\n  // hack to add walking to driving/TNC trips\n  if (hasCar(params.mode)) {\n    params.mode += ',WALK'\n  }\n\n  return params\n}\n\n// Park and Ride location query\n\nexport const parkAndRideError = createAction('PARK_AND_RIDE_ERROR')\nexport const parkAndRideResponse = createAction('PARK_AND_RIDE_RESPONSE')\n\nexport function parkAndRideQuery (params) {\n  let endpoint = 'park_and_ride'\n  if (params && Object.keys(params).length > 0) {\n    endpoint += '?' + Object.keys(params).map(key => key + '=' + params[key]).join('&')\n  }\n  return createQueryAction(endpoint, parkAndRideResponse, parkAndRideError)\n}\n\n// bike rental station query\n\nexport const bikeRentalError = createAction('BIKE_RENTAL_ERROR')\nexport const bikeRentalResponse = createAction('BIKE_RENTAL_RESPONSE')\n\nexport function bikeRentalQuery (params) {\n  return createQueryAction('bike_rental', bikeRentalResponse, bikeRentalError)\n}\n\n// Car rental (e.g. car2go) locations lookup query\n\nexport const carRentalResponse = createAction('CAR_RENTAL_RESPONSE')\nexport const carRentalError = createAction('CAR_RENTAL_ERROR')\n\nexport function carRentalQuery (params) {\n  return createQueryAction('car_rental', carRentalResponse, carRentalError)\n}\n\n// Vehicle rental locations lookup query. For now, there are 3 seperate\n// \"vehicle\" rental endpoints - 1 for cars, 1 for bicycle rentals and another\n// for micromobility. In the future, the hope is to consolidate these 3\n// endpoints into one.\n\nexport const vehicleRentalResponse = createAction('VEHICLE_RENTAL_RESPONSE')\nexport const vehicleRentalError = createAction('VEHICLE_RENTAL_ERROR')\n\nexport function vehicleRentalQuery (params) {\n  return createQueryAction('vehicle_rental', vehicleRentalResponse, vehicleRentalError)\n}\n\n// Single stop lookup query\nconst findStopResponse = createAction('FIND_STOP_RESPONSE')\nconst findStopError = createAction('FIND_STOP_ERROR')\n\nexport function findStop (params) {\n  return createQueryAction(\n    `index/stops/${params.stopId}`,\n    findStopResponse,\n    findStopError,\n    {\n      serviceId: 'stops',\n      postprocess: (payload, dispatch) => {\n        dispatch(findRoutesAtStop(params.stopId))\n        dispatch(findStopTimesForStop(params))\n      },\n      noThrottle: true\n    }\n  )\n}\n\n// TODO: Optionally substitute GraphQL queries? Note: this is not currently\n// possible because gtfsdb (the alternative transit index used by TriMet) does not\n// support GraphQL queries.\n// export function findStop (params) {\n//   const query = `\n// query stopQuery($stopId: [String]) {\n//   stops (ids: $stopId) {\n//     id: gtfsId\n//     code\n//     name\n//     url\n//     lat\n//     lon\n//     stoptimesForPatterns {\n//       pattern {\n//         id: semanticHash\n//         route {\n//           id: gtfsId\n//           longName\n//           shortName\n//           sortOrder\n//         }\n//       }\n//       stoptimes {\n//         scheduledArrival\n//         realtimeArrival\n//         arrivalDelay\n//         scheduledDeparture\n//         realtimeDeparture\n//         departureDelay\n//         timepoint\n//         realtime\n//         realtimeState\n//         serviceDay\n//         headsign\n//       }\n//     }\n//   }\n// }\n// `\n//   return createGraphQLQueryAction(\n//     query,\n//     { stopId: params.stopId },\n//     findStopResponse,\n//     findStopError,\n//     {\n//       // find stop should not be throttled since it can make quite frequent\n//       // updates when fetching stop times for a stop\n//       noThrottle: true,\n//       serviceId: 'stops',\n//       rewritePayload: (payload) => {\n//         // convert pattern array to ID-mapped object\n//         const patterns = []\n//         const { stoptimesForPatterns, ...stop } = payload.data.stops[0]\n//         stoptimesForPatterns.forEach(obj => {\n//           const { pattern, stoptimes: stopTimes } = obj\n//           // It's possible that not all stop times for a pattern will share the\n//           // same headsign, but this is probably a minor edge case.\n//           const headsign = stopTimes[0]\n//             ? stopTimes[0].headsign\n//             : pattern.route.longName\n//           const patternIndex = patterns.findIndex(p =>\n//             p.headsign === headsign && pattern.route.id === p.route.id)\n//           if (patternIndex === -1) {\n//             patterns.push({ ...pattern, headsign, stopTimes })\n//           } else {\n//             patterns[patternIndex].stopTimes.push(...stopTimes)\n//           }\n//         })\n//         return {\n//           ...stop,\n//           patterns\n//         }\n//       }\n//     }\n//   )\n// }\n\n// Single trip lookup query\n\nexport const findTripResponse = createAction('FIND_TRIP_RESPONSE')\nexport const findTripError = createAction('FIND_TRIP_ERROR')\n\nexport function findTrip (params) {\n  return createQueryAction(\n    `index/trips/${params.tripId}`,\n    findTripResponse,\n    findTripError,\n    {\n      postprocess: (payload, dispatch) => {\n        dispatch(findStopsForTrip({tripId: params.tripId}))\n        dispatch(findStopTimesForTrip({tripId: params.tripId}))\n        dispatch(findGeometryForTrip({tripId: params.tripId}))\n      }\n    }\n  )\n}\n\n// Stops for trip query\n\nexport const findStopsForTripResponse = createAction('FIND_STOPS_FOR_TRIP_RESPONSE')\nexport const findStopsForTripError = createAction('FIND_STOPS_FOR_TRIP_ERROR')\n\nexport function findStopsForTrip (params) {\n  return createQueryAction(\n    `index/trips/${params.tripId}/stops`,\n    findStopsForTripResponse,\n    findStopsForTripError,\n    {\n      rewritePayload: (payload) => {\n        return {\n          tripId: params.tripId,\n          stops: payload\n        }\n      }\n    }\n  )\n}\n\n// Stop times for trip query\n\nexport const findStopTimesForTripResponse = createAction('FIND_STOP_TIMES_FOR_TRIP_RESPONSE')\nexport const findStopTimesForTripError = createAction('FIND_STOP_TIMES_FOR_TRIP_ERROR')\n\nexport function findStopTimesForTrip (params) {\n  return createQueryAction(\n    `index/trips/${params.tripId}/stoptimes`,\n    findStopTimesForTripResponse,\n    findStopTimesForTripError,\n    {\n      rewritePayload: (payload) => {\n        return {\n          tripId: params.tripId,\n          stopTimes: payload\n        }\n      },\n      noThrottle: true\n    }\n  )\n}\n\n// Geometry for trip query\n\nexport const findGeometryForTripResponse = createAction('FIND_GEOMETRY_FOR_TRIP_RESPONSE')\nexport const findGeometryForTripError = createAction('FIND_GEOMETRY_FOR_TRIP_ERROR')\n\nexport function findGeometryForTrip (params) {\n  const { tripId } = params\n  return createQueryAction(\n    `index/trips/${tripId}/geometry`,\n    findGeometryForTripResponse,\n    findGeometryForTripError,\n    {\n      rewritePayload: (payload) => ({ tripId, geometry: payload })\n    }\n  )\n}\n\nconst findStopTimesForStopResponse = createAction('FIND_STOP_TIMES_FOR_STOP_RESPONSE')\nconst findStopTimesForStopError = createAction('FIND_STOP_TIMES_FOR_STOP_ERROR')\n\n/**\n * Stop times for stop query (used in stop viewer).\n */\nexport function findStopTimesForStop (params) {\n  return function (dispatch, getState) {\n    let { stopId, ...otherParams } = params\n    // If other params not provided, fall back on defaults from stop viewer config.\n    const queryParams = { ...getStopViewerConfig(getState().otp), ...otherParams }\n    // If no start time is provided, pass in the current time. Note: this is not\n    // a required param by the back end, but if a value is not provided, the\n    // time defaults to the server's time, which can make it difficult to test\n    // scenarios when you may want to use a different date/time for your local\n    // testing environment.\n    if (!queryParams.startTime) {\n      const nowInSeconds = Math.floor((new Date()).getTime() / 1000)\n      queryParams.startTime = nowInSeconds\n    }\n    dispatch(createQueryAction(\n      `index/stops/${stopId}/stoptimes?${qs.stringify(queryParams)}`,\n      findStopTimesForStopResponse,\n      findStopTimesForStopError,\n      {\n        rewritePayload: (stopTimes) => {\n          return {\n            stopId,\n            stopTimes\n          }\n        },\n        noThrottle: true\n      }\n    ))\n  }\n}\n\n// Routes lookup query\n\nconst findRoutesResponse = createAction('FIND_ROUTES_RESPONSE')\nconst findRoutesError = createAction('FIND_ROUTES_ERROR')\n\nexport function findRoutes (params) {\n  return createQueryAction(\n    'index/routes',\n    findRoutesResponse,\n    findRoutesError,\n    {\n      serviceId: 'routes',\n      rewritePayload: (payload) => {\n        const routes = {}\n        payload.forEach(rte => { routes[rte.id] = rte })\n        return routes\n      }\n    }\n  )\n}\n\n// export function findRoutes (params) {\n//   const query = `\n// {\n//   routes {\n//     id: gtfsId\n//     color\n//     longName\n//     shortName\n//     mode\n//     type\n//     desc\n//     bikesAllowed\n//     sortOrder\n//     textColor\n//     url\n//     agency {\n//       id: gtfsId\n//       name\n//       url\n//     }\n//   }\n// }\n//   `\n//   return createGraphQLQueryAction(\n//     query,\n//     {},\n//     findRoutesResponse,\n//     findRoutesError,\n//     {\n//       serviceId: 'routes',\n//       rewritePayload: (payload) => {\n//         const routes = {}\n//         payload.data.routes.forEach(rte => { routes[rte.id] = rte })\n//         return routes\n//       }\n//     }\n//   )\n// }\n\n// Patterns for Route lookup query\n// TODO: replace with GraphQL query for route => patterns => geometry\nconst findPatternsForRouteResponse = createAction('FIND_PATTERNS_FOR_ROUTE_RESPONSE')\nconst findPatternsForRouteError = createAction('FIND_PATTERNS_FOR_ROUTE_ERROR')\n\n// Single Route lookup query\n\nexport const findRouteResponse = createAction('FIND_ROUTE_RESPONSE')\nexport const findRouteError = createAction('FIND_ROUTE_ERROR')\n\nexport function findRoute (params) {\n  return createQueryAction(\n    `index/routes/${params.routeId}`,\n    findRouteResponse,\n    findRouteError,\n    {\n      postprocess: (payload, dispatch) => {\n        // load patterns\n        dispatch(findPatternsForRoute({ routeId: params.routeId }))\n      },\n      noThrottle: true\n    }\n  )\n}\n\nexport function findPatternsForRoute (params) {\n  return createQueryAction(\n    `index/routes/${params.routeId}/patterns`,\n    findPatternsForRouteResponse,\n    findPatternsForRouteError,\n    {\n      rewritePayload: (payload) => {\n        // convert pattern array to ID-mapped object\n        const patterns = {}\n        payload.forEach(ptn => { patterns[ptn.id] = ptn })\n\n        return {\n          routeId: params.routeId,\n          patterns\n        }\n      },\n      postprocess: (payload, dispatch) => {\n        // load geometry for each pattern\n        payload.forEach(ptn => {\n          dispatch(findGeometryForPattern({\n            routeId: params.routeId,\n            patternId: ptn.id\n          }))\n        })\n      }\n    }\n  )\n}\n\n// Geometry for Pattern lookup query\n\nconst findGeometryForPatternResponse = createAction('FIND_GEOMETRY_FOR_PATTERN_RESPONSE')\nconst findGeometryForPatternError = createAction('FIND_GEOMETRY_FOR_PATTERN_ERROR')\n\nexport function findGeometryForPattern (params) {\n  return createQueryAction(\n    `index/patterns/${params.patternId}/geometry`,\n    findGeometryForPatternResponse,\n    findGeometryForPatternError,\n    {\n      rewritePayload: (payload) => {\n        return {\n          routeId: params.routeId,\n          patternId: params.patternId,\n          geometry: payload\n        }\n      }\n    }\n  )\n}\n\n// export function findRoute (params) {\n//   const query = `\n//   query routeQuery($routeId: [String]) {\n//     routes (ids: $routeId) {\n//       id: gtfsId\n//       patterns {\n//         id: semanticHash\n//         directionId\n//         headsign\n//         name\n//         semanticHash\n//         geometry {\n//           lat\n//           lon\n//         }\n//       }\n//     }\n//   }\n//   `\n//   return createGraphQLQueryAction(\n//     query,\n//     { routeId: params.routeId },\n//     findPatternsForRouteResponse,\n//     findPatternsForRouteError,\n//     {\n//       rewritePayload: (payload) => {\n//         // convert pattern array to ID-mapped object\n//         const patterns = {}\n//         payload.data.routes[0].patterns.forEach(ptn => {\n//           patterns[ptn.id] = {\n//             routeId: params.routeId,\n//             patternId: ptn.id,\n//             geometry: ptn.geometry\n//           }\n//         })\n//\n//         return {\n//           routeId: params.routeId,\n//           patterns\n//         }\n//       }\n//     }\n//   )\n// }\n\n// TNC ETA estimate lookup query\n\nexport const transportationNetworkCompanyEtaResponse = createAction('TNC_ETA_RESPONSE')\nexport const transportationNetworkCompanyEtaError = createAction('TNC_ETA_ERROR')\n\nexport function getTransportationNetworkCompanyEtaEstimate (params) {\n  const {companies, from} = params\n  return createQueryAction(\n    `transportation_network_company/eta_estimate?${qs.stringify({\n      companies,\n      from\n    })}`, // endpoint\n    transportationNetworkCompanyEtaResponse, // responseAction\n    transportationNetworkCompanyEtaError, // errorAction\n    {\n      rewritePayload: (payload) => {\n        return {\n          from,\n          estimates: payload.estimates\n        }\n      }\n    }\n  )\n}\n\n// TNC ride estimate lookup query\n\nexport const transportationNetworkCompanyRideResponse = createAction('TNC_RIDE_RESPONSE')\nexport const transportationNetworkCompanyRideError = createAction('TNC_RIDE_ERROR')\n\nexport function getTransportationNetworkCompanyRideEstimate (params) {\n  const {company, from, rideType, to} = params\n  return createQueryAction(\n    `transportation_network_company/ride_estimate?${qs.stringify({\n      company,\n      from,\n      rideType,\n      to\n    })}`, // endpoint\n    transportationNetworkCompanyRideResponse, // responseAction\n    transportationNetworkCompanyRideError, // errorAction\n    {\n      rewritePayload: (payload) => {\n        return {\n          company,\n          from,\n          rideEstimate: payload.rideEstimate,\n          to\n        }\n      }\n    }\n  )\n}\n\n// Nearby Stops Query\n\nconst receivedNearbyStopsResponse = createAction('NEARBY_STOPS_RESPONSE')\nconst receivedNearbyStopsError = createAction('NEARBY_STOPS_ERROR')\n\nexport function findNearbyStops (params) {\n  return createQueryAction(\n    `index/stops?${qs.stringify({radius: 1000, ...params})}`,\n    receivedNearbyStopsResponse,\n    receivedNearbyStopsError,\n    {\n      serviceId: 'stops',\n      rewritePayload: stops => {\n        if (stops) {\n          // Sort the stops by proximity\n          stops.forEach(stop => {\n            stop.distance = haversine(\n              { latitude: params.lat, longitude: params.lon },\n              { latitude: stop.lat, longitude: stop.lon }\n            )\n          })\n          stops.sort((a, b) => { return a.distance - b.distance })\n          if (params.max && stops.length > params.max) stops = stops.slice(0, params.max)\n        }\n        return {stops}\n      },\n      // retrieve routes for each stop\n      postprocess: (stops, dispatch, getState) => {\n        if (params.max && stops.length > params.max) stops = stops.slice(0, params.max)\n        stops.forEach(stop => dispatch(findRoutesAtStop(stop.id)))\n      }\n    }\n  )\n}\n\n// Routes at Stop query\n\nconst receivedRoutesAtStopResponse = createAction('ROUTES_AT_STOP_RESPONSE')\nconst receivedRoutesAtStopError = createAction('ROUTES_AT_STOP_ERROR')\n\nexport function findRoutesAtStop (stopId) {\n  return createQueryAction(\n    `index/stops/${stopId}/routes`,\n    receivedRoutesAtStopResponse,\n    receivedRoutesAtStopError,\n    {\n      serviceId: 'stops/routes',\n      rewritePayload: routes => ({ stopId, routes }),\n      noThrottle: true\n    }\n  )\n}\n\n// Stops within Bounding Box Query\n\nconst receivedStopsWithinBBoxResponse = createAction('STOPS_WITHIN_BBOX_RESPONSE')\nconst receivedStopsWithinBBoxError = createAction('STOPS_WITHIN_BBOX_ERROR')\n\nexport function findStopsWithinBBox (params) {\n  return createQueryAction(\n    `index/stops?${qs.stringify(params)}`,\n    receivedStopsWithinBBoxResponse,\n    receivedStopsWithinBBoxError,\n    {\n      serviceId: 'stops',\n      rewritePayload: stops => ({stops})\n    }\n  )\n}\n\nexport const clearStops = createAction('CLEAR_STOPS_OVERLAY')\n\nconst throttledUrls = {}\n\nfunction now () {\n  return (new Date()).getTime()\n}\n\nconst TEN_SECONDS = 10000\n\n// automatically clear throttled urls older than 10 seconds\nwindow.setInterval(() => {\n  Object.keys(throttledUrls).forEach(key => {\n    if (throttledUrls[key] < now() - TEN_SECONDS) {\n      delete throttledUrls[key]\n    }\n  })\n}, 1000)\n\n/**\n * Generic helper for constructing API queries. Automatically throttles queries\n * to url to no more than once per 10 seconds.\n *\n * @param {string} endpoint - The API endpoint path (does not include\n *   '../otp/routers/router_id/')\n * @param {Function} responseAction - Action to dispatch on a successful API\n *   response. Accepts payload object parameter.\n * @param {Function} errorAction - Function to invoke on API error response.\n *   Accepts error object parameter.\n * @param {Options} options - Any of the following optional settings:\n *   - rewritePayload: Function to be invoked to modify payload before being\n *       passed to responseAction. Accepts and returns payload object.\n *   - postprocess: Function to be invoked after responseAction is invoked.\n *       Accepts payload, dispatch, getState parameters.\n *   - serviceId: identifier for TransitIndex service used in\n *       alternateTransitIndex configuration.\n *   - fetchOptions: fetch options (e.g., method, body, headers).\n */\n\nfunction createQueryAction (endpoint, responseAction, errorAction, options = {}) {\n  return async function (dispatch, getState) {\n    const otpState = getState().otp\n    let url\n    if (options.serviceId && otpState.config.alternateTransitIndex &&\n      otpState.config.alternateTransitIndex.services.includes(options.serviceId)\n    ) {\n      console.log('Using alt service for ' + options.serviceId)\n      url = otpState.config.alternateTransitIndex.apiRoot + endpoint\n    } else {\n      const api = otpState.config.api\n      url = `${api.host}${api.port ? ':' + api.port : ''}${api.path}/${endpoint}`\n    }\n\n    if (!options.noThrottle) {\n      // don't make a request to a URL that has already seen the same request\n      // within the last 10 seconds\n      const throttleKey = options.fetchOptions\n        ? `${url}-${hash(options.fetchOptions)}`\n        : url\n      if (throttledUrls[throttleKey] && throttledUrls[throttleKey] > now() - TEN_SECONDS) {\n        // URL already had a request within last 10 seconds, warn and exit\n        console.warn(`Request throttled for url: ${url}`)\n        return\n      } else {\n        throttledUrls[throttleKey] = now()\n      }\n    }\n    let payload\n    try {\n      const response = await fetch(url, options.fetchOptions)\n      if (response.status >= 400) {\n        const error = new Error('Received error from server')\n        error.response = response\n        throw error\n      }\n      payload = await response.json()\n    } catch (err) {\n      return dispatch(errorAction(err))\n    }\n\n    if (typeof options.rewritePayload === 'function') {\n      dispatch(responseAction(options.rewritePayload(payload)))\n    } else {\n      dispatch(responseAction(payload))\n    }\n\n    if (typeof options.postprocess === 'function') {\n      options.postprocess(payload, dispatch, getState)\n    }\n  }\n}\n\n// TODO: Determine how we might be able to use GraphQL with the alternative\n// transit index. Currently this is not easily possible because the alternative\n// transit index does not have support for GraphQL and handling both Rest and\n// GraphQL queries could introduce potential difficulties for maintainers.\n// function createGraphQLQueryAction (query, variables, responseAction, errorAction, options) {\n//   const endpoint = `index/graphql`\n//   const fetchOptions = {\n//     method: 'POST',\n//     body: JSON.stringify({ query, variables }),\n//     headers: { 'Content-Type': 'application/json' }\n//   }\n//   return createQueryAction(\n//     endpoint,\n//     responseAction,\n//     errorAction,\n//     { ...options, fetchOptions }\n//   )\n// }\n\n/**\n * Update the browser/URL history with new parameters\n * NOTE: This has not been tested for profile-based journeys.\n */\nexport function setUrlSearch (params, replaceCurrent = false) {\n  return function (dispatch, getState) {\n    const base = getState().router.location.pathname\n    const path = `${base}?${qs.stringify(params, { arrayFormat: 'repeat' })}`\n    if (replaceCurrent) dispatch(replace(path))\n    else dispatch(push(path))\n  }\n}\n\n/**\n * Update the OTP Query parameters in the URL and ensure that the active search\n * is set correctly. Leaves any other existing URL parameters (e.g., UI) unchanged.\n */\nfunction updateOtpUrlParams (otpState, searchId) {\n  const {config, currentQuery} = otpState\n  // Get updated OTP params from current query.\n  const otpParams = getRoutingParams(currentQuery, config, true)\n  return function (dispatch, getState) {\n    const params = {}\n    // Get all URL params and ensure non-routing params (UI, sessionId) remain\n    // unchanged.\n    const urlParams = getUrlParams()\n    Object.keys(urlParams)\n      // If param is non-routing, add to params to keep the same after update.\n      .filter(key => key.indexOf('_') !== -1 || key === 'sessionId')\n      .forEach(key => { params[key] = urlParams[key] })\n    params.ui_activeSearch = searchId\n    // Assumes this is a new search and the active itinerary should be reset.\n    params.ui_activeItinerary = 0\n    // Merge in the provided OTP params and update the URL\n    dispatch(setUrlSearch(Object.assign(params, otpParams)))\n  }\n}\n"]}